{"version":3,"sources":["ng://@kleiolab/lib-utils/src/lib/time-span/time-span.ts"],"names":["TimeSpan","data","_this","this","tpKeys","Object","keys","forEach","key","undefined","assign","TimePrimitive","defineProperty","prototype","isEmpty","min","Number","POSITIVE_INFINITY","current","julianDay","getMinMaxTimePrimitveOfArray","tps","length","max","tp","getJulianSecond","fromTimeSpanDialogData","d","x","isNotEmpty","p82","p81","p82a","p82b","p81a","p81b","getMinMaxTimePrimitive","getArrayOfTimePrimitives","array","push","getPrimitivesForPreview","single","begin","end"],"mappings":"wmBAgBA,IAAAA,EAAA,WAwEE,SAAAA,EAAYC,GAAZ,IAAAC,EAAAC,KAtESA,KAAAC,OAAS,CAAC,MAAO,MAAO,OAAQ,OAAQ,OAAQ,QAuEnDH,IACFI,OAAOC,KAAKL,GAAMM,SAAO,SAACC,GAAO,YAAcC,IAAdR,EAAKO,UAA4BP,EAAKO,GAAO,MAC9EH,OAAOK,OAAOP,KAAMF,GACpBE,KAAKC,OAAOG,SAAO,SAACC,GACdN,EAAKM,KAAMN,EAAKM,GAAO,IAAIG,EAAAA,cAAcT,EAAKM,SAuD1D,OAxHEH,OAAAO,eAAIZ,EAAAa,UAAA,cAAW,KAAf,WAAA,IAAAX,EAAAC,KAEE,GAAIA,KAAKW,UAAW,OAAO,SAEvBC,EAAMC,OAAOC,kBAUjB,OARAd,KAAKC,OAAOG,SAAO,SAACC,GAClB,GAAIN,EAAKM,GAAM,KACPU,EAAUhB,EAAKM,GAAKW,UAE1BJ,EAAMG,EAAUH,EAAMG,EAAUH,MAI7BA,mCAWFf,EAAAoB,6BAAP,SAAoCC,GAElC,IAAKA,GAAOA,EAAIC,OAAS,EAAG,OAAO,SAE/BP,EAAMM,EAAI,GACVE,EAAMF,EAAI,GAed,OAbAA,EAAId,SAAO,SAACiB,GAGVT,EAAMS,EAAGC,kBAAoBV,EAAIU,kBAAoBD,EAAKT,EAG1DQ,EAAMC,EAAGC,kBAAoBF,EAAIE,kBAAoBD,EAAKD,KAOrD,CAAER,IAAKA,EAAKQ,IAAKA,IAGnBvB,EAAA0B,uBAAP,SAA8BC,QAAA,IAAAA,IAAAA,EAAA,IACvBA,IAAGA,EAAI,QACNC,EAAI,GAOV,OANID,EAAE,MAAOC,EAAO,IAAID,EAAE,KACtBA,EAAE,MAAOC,EAAO,IAAID,EAAE,KACtBA,EAAE,OAAQC,EAAQ,KAAID,EAAE,MACxBA,EAAE,OAAQC,EAAQ,KAAID,EAAE,MACxBA,EAAE,OAAQC,EAAQ,KAAID,EAAE,MACxBA,EAAE,OAAQC,EAAQ,KAAID,EAAE,MACrB,IAAI3B,EAAS4B,IAiBtB5B,EAAAa,UAAAC,QAAA,WACE,OAAQX,KAAK0B,cAKf7B,EAAAa,UAAAgB,WAAA,WACE,SAAI1B,KAAK2B,KAAO3B,KAAK4B,KAAO5B,KAAK6B,MAAQ7B,KAAK8B,MAAQ9B,KAAK+B,MAAQ/B,KAAKgC,OAa1EnC,EAAAa,UAAAuB,uBAAA,WACE,OAAOpC,EAASoB,6BAA6BjB,KAAKkC,6BAMpDrC,EAAAa,UAAAwB,yBAAA,WAAA,IAAAnC,EAAAC,KACQmC,EAAQ,GAQd,OANAnC,KAAKC,OAAOG,SAAO,SAACC,GACdN,EAAKM,IACP8B,EAAMC,KAAKrC,EAAKM,OAIb8B,GAGTtC,EAAAa,UAAA2B,wBAAA,WAIE,MAAO,CAAEC,OAHMtC,KAAK2B,KAAO3B,KAAK4B,IAGfW,MAFHvC,KAAK6B,MAAQ7B,KAAK+B,KAERS,IADZxC,KAAK8B,MAAQ9B,KAAKgC,OAIlCnC,EApIA,yBAbgCS","sourcesContent":["import { InfTimePrimitive } from '@kleiolab/lib-sdk-lb3';\nimport { WarEntityPreviewTimeSpan } from '@kleiolab/lib-sdk-lb4';\nimport { CalendarType, TimePrimitive } from '@kleiolab/lib-utils/src/lib/date-time';\nexport const x: TimePrimitive = undefined\nexport interface InfTimePrimitiveWithCalendar extends InfTimePrimitive {\n  calendar: CalendarType\n}\nexport interface TimeSpanWithNumberProps {\n  // key is the dfh_pk_property, expressing what the time primitive means for the time span\n  72?: InfTimePrimitiveWithCalendar; // p82 | At some time within | outer bounds | not before â not after\n  152?: InfTimePrimitiveWithCalendar; // p82a | begin of the begin | left outer bound | not before\n  153?: InfTimePrimitiveWithCalendar; // p82b | end of the end |Â right outer bound |Â not after\n  71?: InfTimePrimitiveWithCalendar; // p81 | Ongoing throughout | inner bounds | surely from â surely to\n  150?: InfTimePrimitiveWithCalendar; // p81a | end of the begin | left inner bound | surely from\n  151?: InfTimePrimitiveWithCalendar; // p81b | begin of the end | right inner bound | surely to\n}\nexport class TimeSpan {\n\n  readonly tpKeys = ['p82', 'p81', 'p82a', 'p82b', 'p81a', 'p81b']\n\n  p82?: TimePrimitive; // At some time within | outer bounds | not before â not after\n  p81?: TimePrimitive; // Ongoing throughout | inner bounds | surely from â surely to\n  p82a?: TimePrimitive; // begin of the begin | left outer bound | not before\n  p81a?: TimePrimitive; // end of the begin | left inner bound | surely from\n  p81b?: TimePrimitive; // begin of the end | right inner bound | surely to\n  p82b?: TimePrimitive; // end of the end |Â right outer bound |Â not after\n\n\n  get earliestDay() {\n\n    if (this.isEmpty()) return null;\n\n    let min = Number.POSITIVE_INFINITY;\n\n    this.tpKeys.forEach(key => {\n      if (this[key]) {\n        const current = this[key].julianDay;\n        // if this timePrimitive is earlier than min, set this as new min\n        min = current < min ? current : min;\n      }\n    })\n\n    return min;\n  }\n\n  /**\n  * get the earliest and latest TimePrimitive of given array of TimePrimitives\n  *\n  * For earliest it compares the begin of TimePrimitive duration\n  * For latest it compares the last second of TimePrimitive duration\n  *\n  * @returns object with min Date and max Date or null, if no TimePrimitive available\n  */\n  static getMinMaxTimePrimitveOfArray(tps: TimePrimitive[]) {\n\n    if (!tps || tps.length < 1) return null;\n\n    let min = tps[0];\n    let max = tps[0];\n\n    tps.forEach(tp => {\n\n      // if this timePrimitive is earlier than min, set this as new min\n      min = tp.getJulianSecond() < min.getJulianSecond() ? tp : min;\n\n      // if this timePrimitive is later than max, set this as new max\n      max = tp.getJulianSecond() > max.getJulianSecond() ? tp : max;\n      //  check if we would need the latest second here?\n      // max = tp.getLastSecond() > max.getLastSecond() ? tp : max;\n\n\n    })\n\n    return { min: min, max: max };\n  }\n\n  static fromTimeSpanDialogData(d: TimeSpanWithNumberProps = {}): TimeSpan {\n    if (!d) d = {};\n    const x = {}\n    if (d['72']) x['p82'] = d['72'];\n    if (d['71']) x['p81'] = d['71'];\n    if (d['152']) x['p82a'] = d['152'];\n    if (d['150']) x['p81a'] = d['150'];\n    if (d['151']) x['p81b'] = d['151'];\n    if (d['153']) x['p82b'] = d['153'];\n    return new TimeSpan(x)\n  }\n\n  constructor(data?: WarEntityPreviewTimeSpan) {\n    if (data) {\n      Object.keys(data).forEach(key => data[key] === undefined ? delete data[key] : '');\n      Object.assign(this, data);\n      this.tpKeys.forEach(key => {\n        if (this[key]) this[key] = new TimePrimitive(this[key]);\n      })\n    }\n  }\n\n\n  /**\n   * returns true if no TimePrimitive is there\n   */\n  isEmpty(): boolean {\n    return !this.isNotEmpty()\n  }\n  /**\n   * returns true if at least one TimePrimitive is there\n   */\n  isNotEmpty(): boolean {\n    if (this.p82 || this.p81 || this.p82a || this.p82b || this.p81a || this.p81b) return true\n    else return false\n  }\n\n\n  /**\n  * get the earliest and latest TimePrimitive of this TimeSpan\n  *\n  * For earliest it compares the begin of TimePrimitive duration\n  * For latest it compares the last second of TimePrimitive duration\n  *\n  * @returns object with min Date and max Date or null, if no TimePrimitive available\n  */\n  getMinMaxTimePrimitive(): { min: TimePrimitive, max: TimePrimitive } | null {\n    return TimeSpan.getMinMaxTimePrimitveOfArray(this.getArrayOfTimePrimitives());\n  }\n\n  /**\n   * @returns array of TimePrimitives of this TimeSpan\n   */\n  getArrayOfTimePrimitives(): TimePrimitive[] {\n    const array = [];\n\n    this.tpKeys.forEach(key => {\n      if (this[key]) {\n        array.push(this[key]);\n      }\n    })\n\n    return array;\n  }\n\n  getPrimitivesForPreview(): { single?: TimePrimitive, begin?: TimePrimitive, end?: TimePrimitive } {\n    const single = this.p82 || this.p81;\n    const begin = this.p82a || this.p81a;\n    const end = this.p82b || this.p81b;\n    return { single, begin, end };\n  }\n\n}\n"]}