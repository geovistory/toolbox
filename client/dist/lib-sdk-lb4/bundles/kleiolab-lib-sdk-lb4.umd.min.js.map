{"version":3,"sources":["ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/configuration.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api.module.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/encoder.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/variables.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/account.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/analysis.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/contentTree.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/datChunk.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/datChunkController.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/datColumn.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/datDigital.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/datNamespace.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/dfhClassController.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/dfhLabel.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/dfhProfile.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/dfhPropertyController.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/factoidController.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/importTableController.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/infLanguage.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/infPersistentItem.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/infPlace.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/infStatement.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/infTemporalEntity.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/infTextProperty.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/pingController.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/proClassFieldConfig.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/proDfhClassProjRel.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/proDfhProfileProjRel.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/proInfoProjRel.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/proProject.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/proTextProperty.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/projectConfiguration.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/pubAccount.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/ramList.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/schemaObject.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/subfieldPageController.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/sysClassField.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/sysClassHasTypeProperty.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/sysSystemRelevantClass.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/sysSystemType.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/systemConfiguration.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/table.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/warEntityPreviewController.service.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/api/api.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/gvSubentityTargetType.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/gvTargetType.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/queryFilterData.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/sysConfigValueObjectType.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/timePrimitiveWithCal.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/warStatementTimePrimitiveVT.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/analysisTableExportRequest.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/colDef.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/getTablePageOptions.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/queryPathSegment.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/tColFilterNum.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/tColFilterTxt.ts","ng://@kleiolab/lib-sdk-lb4/lib/sdk-lb4/model/warStatementGeoJson.ts"],"names":["Configuration","configurationParameters","_this","this","apiKeys","username","password","accessToken","basePath","withCredentials","encoder","credentials","prototype","selectHeaderContentType","contentTypes","length","type","find","x","isJsonMime","undefined","selectHeaderAccept","accepts","mime","jsonMime","RegExp","test","toLowerCase","lookupCredential","key","value","ApiModule","parentModule","http","Error","forRoot","configurationFactory","ngModule","providers","provide","useFactory","NgModule","args","imports","declarations","exports","decorators","Optional","SkipSelf","HttpClient","CustomHttpParameterCodec","encodeKey","k","encodeURIComponent","encodeValue","v","decodeKey","decodeURIComponent","decodeValue","BASE_PATH","InjectionToken","AccountService","httpClient","configuration","defaultHeaders","HttpHeaders","addToHttpParams","httpParams","Date","addToHttpParamsRecursive","Array","isArray","forEach","elem","append","toISOString","substr","Object","keys","accountControllerForgotPassword","email","observe","reportProgress","options","queryParameters","HttpParams","credential","headers","set","httpHeaderAcceptSelected","httpHeaderAccept","responseType","startsWith","get","params","accountControllerLogin","loginRequest","httpContentTypeSelected","post","accountControllerResetPassword","resetPasswordRequest","accountControllerSignUp","signupRequest","accountControllerVerifyEmail","accountId","verificationToken","redirectOnSuccess","accountControllerWhoAmI","Injectable","providedIn","Inject","AnalysisService","analysisControllerBulkDelete","pkProject","requestBody","put","analysisControllerBulkUpsert","proAnalysis","analysisControllerGetVersion","pkEntity","version","analysisControllerMapRun","analysisMapRequest","analysisControllerOfProject","analysisControllerTableExport","analysisTableExportRequest","analysisControllerTableRun","analysisTableRequest","analysisControllerTimeChartRun","analysisTimeChartRequest","ContentTreeService","contentTreeControllerGetContentTree","pkExpressionEntity","DatChunkService","datChunkFindById","id","filter","String","datChunkOfDigital","pkDigital","DatChunkControllerService","datChunkControllerFindById","DatColumnService","datColumnOfDigital","DatDigitalService","datDigitalBulkDelete","datDigitalBulkUpsert","pkNamespace","datDigital","datDigitalFindById","datDigitalGetTablePage","body","datDigitalGetVersion","entityVersion","DatNamespaceService","datNamespaceByProject","datNamespaceFind","datNamespaceFindById","DfhClassControllerService","dfhClassControllerOfProject","DfhLabelService","dfhLabelOfProject","DfhProfileService","dfhProfileDeactivateProfileForProject","pkProfile","dfhProfileGetActivationReport","requestedLanguage","dfhProfileGetDeactivationReport","dfhProfileOfProject","dfhProfileUpdateAndAddToProject","dfhProfileUpdateFromOntoMe","DfhPropertyControllerService","dfhPropertyControllerOfProject","FactoidControllerService","factoidControllerFactoidsFromEntity","factoidNumber","page","ImportTableControllerService","importTableControllerImportTable","importTable","InfLanguageService","infLanguageFind","infLanguageQueryByString","queryString","InfPersistentItemService","infPersistentItemFindOrCreateInfPersistentItems","infPersistentItem","infPersistentItemOwnProperties","infPersistentItemTypeNested","infPersistentItemTypesOfClassesAndProject","pkTypedClasses","infPersistentItemTypesOfProject","InfPlaceService","infPlaceFind","infPlaceFindOrCreatePlace","projectId","infPlace","InfStatementService","infStatementAlternativesNotInProjectByEntityPk","entityPk","propertyPk","infStatementAlternativesNotInProjectByTeEntPk","teEntPk","infStatementFindOrCreateInfStatements","infStatement","infStatementPaginatedListTargetingEntityPreviews","pkSourceEntity","pkProperty","pkTargetClass","isOutgoing","limit","offset","infStatementQueryByParams","ofProject","pkInfoRange","pkInfoDomain","infStatementSourcesAndDigitalsOfEntity","InfTemporalEntityService","infTemporalEntityAlternativeTemporalEntityList","infTemporalEntityChangeTeEntProjectRelation","isInProject","infTemporalEntity","infTemporalEntityFind","infTemporalEntityFindOrCreateInfTemporalEntities","infTemporalEntityFindOrCreateInfTemporalEntity","infTemporalEntityOwnProperties","infTemporalEntityTemporalEntityList","InfTextPropertyService","infTextPropertyFindAlternativeTextProperties","pkClassField","infTextPropertyFindOrCreateInfTextProperties","infTextProperty","infTextPropertyFindOrCreateInfTextProperty","PingControllerService","pingControllerPing","pingControllerProjectPing","pingControllerProjectPong","projectPongRequest","pingControllerSysAdminPing","ProClassFieldConfigService","proClassFieldConfigBulkDelete","proClassFieldConfigBulkUpsert","proClassFieldConfig","proClassFieldConfigOfProject","proClassFieldConfigPatchOrCreate","patch","ProDfhClassProjRelService","proDfhClassProjRelBulkUpsert","proDfhClassProjRel","proDfhClassProjRelCreate","newProDfhClassProjRel","proDfhClassProjRelOfProject","ProDfhProfileProjRelService","proDfhProfileProjRelBulkUpsert","proDfhProfileProjRel","proDfhProfileProjRelOfProject","ProInfoProjRelService","proInfoProjRelBulkUpdateEprAttributes","proInfoProjRel","proInfoProjRelFind","proInfoProjRelMarkStatementAsFavorite","pkStatement","proInfoProjRelPatchOrCreate","proInfoProjRelUpdateEprAttributes","ProProjectService","proProjectCreateWithLabelAndDescription","pkLanguage","label","textProperty","proProjectGetBasics","proProjectOfAccount","ProTextPropertyService","proTextPropertyBulkDelete","proTextProperty","proTextPropertyBulkUpsert","proTextPropertyOfProject","ProjectConfigurationService","projectConfigControllerDeleteEntityLabelConfig","fkClass","delete","projectConfigControllerGetEntityLabelConfig","projectConfigControllerPostEntityLabelConfig","proEntityLabelConfig","PubAccountService","pubAccountGetRoles","pubAccountListProjects","pubAccountLogin","include","pubAccountLogout","pubAccountWithRolesAndProjects","RamListService","ramListControllerGetRamList","fkProperty","refersTo","SchemaObjectService","schemaObjectAddEntityToProject","schemaObjectRemoveEntityFromProject","schemaObjectTypeOfProject","pkType","SubfieldPageControllerService","subfieldPageControllerAlternativeLeafItems","gvPaginationAlternativeLeafItemsReq","subfieldPageControllerLoadSubfieldPage","gvFieldPageReq","SysClassFieldService","sysClassFieldFind","sysClassFieldFindComplex","SysClassHasTypePropertyService","sysClassHasTypePropertyFind","SysSystemRelevantClassService","sysSystemRelevantClassBulkReplaceOrCreate","sysSystemRelevantClass","sysSystemRelevantClassFind","SysSystemTypeService","sysSystemTypeFind","SystemConfigurationService","sysConfigControllerGetSystemConfig","sysConfigControllerSetSystemConfig","sysConfigValue","sysConfigControllerValidateSystemConfig","TableService","tableControllerGetTableColumns","tableControllerGetTablePage","getTablePageOptions","WarEntityPreviewControllerService","warEntityPreviewControllerPaginatedListByPks","warEntityPreviewPaginatedByPkReq","warEntityPreviewControllerSearch","warEntityPreviewSearchExistingReq","warEntityPreviewControllerSearchExisting","GvSubentityTargetType","GvTargetType","QueryFilterData","SysConfigValueObjectType","TimePrimitiveWithCal","WarStatementTimePrimitiveVT","APIS","AnalysisTableExportRequest","FileTypeEnum","Json","Csv","ColDef","DefaultTypeEnum","EntityPreview","EntityLabel","ClassLabel","TypeLabel","TemporalDistribution","SpaceAndTimeCont","GetTablePageOptions","SortDirectionEnum","Asc","Desc","AppellationEnum","True","LanguageEnum","PlaceEnum","TimePrimitiveEnum","LangStringEnum","EntityPreviewEnum","TypeItemEnum","TimeSpanEnum","TextPropertyEnum","SubgroupEnum","Property","ClassAndType","OperatorEnum","Is","IsNot","EntityLabelContains","And","Or","QueryPathSegment","TypeEnum","Properties","Classes","TColFilterNum","Equal","LessThan","GreaterThan","TColFilterTxt","ILike","DurationEnum","Century","Decade","Year","Month","Day","Hour","Minute","Second","CalendarEnum","Gregorian","Julian","WarStatementGeoJson","Point","csv","tsv","ssv","pipes"],"mappings":"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","sourcesContent":["import { HttpParameterCodec } from '@angular/common/http';\n\nexport interface ConfigurationParameters {\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n    /**\n     * The keys are the names in the securitySchemes section of the OpenAPI\n     * document. They should map to the value used for authentication\n     * minus any standard prefixes such as 'Basic' or 'Bearer'.\n     */\n    credentials?: {[ key: string ]: string | (() => string | undefined)};\n}\n\nexport class Configuration {\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n    /**\n     * The keys are the names in the securitySchemes section of the OpenAPI\n     * document. They should map to the value used for authentication\n     * minus any standard prefixes such as 'Basic' or 'Bearer'.\n     */\n    credentials: {[ key: string ]: string | (() => string | undefined)};\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n        this.encoder = configurationParameters.encoder;\n        if (configurationParameters.credentials) {\n            this.credentials = configurationParameters.credentials;\n        }\n        else {\n            this.credentials = {};\n        }\n\n        // init default accesstoken credential\n        if (!this.credentials['accesstoken']) {\n            this.credentials['accesstoken'] = () => {\n                return this.apiKeys['accesstoken'] || this.apiKeys['authorization'];\n            };\n        }\n\n        // init default jwt credential\n        if (!this.credentials['jwt']) {\n            this.credentials['jwt'] = () => {\n                return typeof this.accessToken === 'function'\n                    ? this.accessToken()\n                    : this.accessToken;\n            };\n        }\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length === 0) {\n            return undefined;\n        }\n\n        const type = contentTypes.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length === 0) {\n            return undefined;\n        }\n\n        const type = accepts.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n\n    public lookupCredential(key: string): string | undefined {\n        const value = this.credentials[key];\n        return typeof value === 'function'\n            ? value()\n            : value;\n    }\n}\n","import { NgModule, ModuleWithProviders, SkipSelf, Optional } from '@angular/core';\nimport { Configuration } from './configuration';\nimport { HttpClient } from '@angular/common/http';\n\nimport { AccountService } from './api/account.service';\nimport { AnalysisService } from './api/analysis.service';\nimport { ContentTreeService } from './api/contentTree.service';\nimport { DatChunkService } from './api/datChunk.service';\nimport { DatChunkControllerService } from './api/datChunkController.service';\nimport { DatColumnService } from './api/datColumn.service';\nimport { DatDigitalService } from './api/datDigital.service';\nimport { DatNamespaceService } from './api/datNamespace.service';\nimport { DfhClassControllerService } from './api/dfhClassController.service';\nimport { DfhLabelService } from './api/dfhLabel.service';\nimport { DfhProfileService } from './api/dfhProfile.service';\nimport { DfhPropertyControllerService } from './api/dfhPropertyController.service';\nimport { FactoidControllerService } from './api/factoidController.service';\nimport { ImportTableControllerService } from './api/importTableController.service';\nimport { InfLanguageService } from './api/infLanguage.service';\nimport { InfPersistentItemService } from './api/infPersistentItem.service';\nimport { InfPlaceService } from './api/infPlace.service';\nimport { InfStatementService } from './api/infStatement.service';\nimport { InfTemporalEntityService } from './api/infTemporalEntity.service';\nimport { InfTextPropertyService } from './api/infTextProperty.service';\nimport { PingControllerService } from './api/pingController.service';\nimport { ProClassFieldConfigService } from './api/proClassFieldConfig.service';\nimport { ProDfhClassProjRelService } from './api/proDfhClassProjRel.service';\nimport { ProDfhProfileProjRelService } from './api/proDfhProfileProjRel.service';\nimport { ProInfoProjRelService } from './api/proInfoProjRel.service';\nimport { ProProjectService } from './api/proProject.service';\nimport { ProTextPropertyService } from './api/proTextProperty.service';\nimport { ProjectConfigurationService } from './api/projectConfiguration.service';\nimport { PubAccountService } from './api/pubAccount.service';\nimport { RamListService } from './api/ramList.service';\nimport { SchemaObjectService } from './api/schemaObject.service';\nimport { SubfieldPageControllerService } from './api/subfieldPageController.service';\nimport { SysClassFieldService } from './api/sysClassField.service';\nimport { SysClassHasTypePropertyService } from './api/sysClassHasTypeProperty.service';\nimport { SysSystemRelevantClassService } from './api/sysSystemRelevantClass.service';\nimport { SysSystemTypeService } from './api/sysSystemType.service';\nimport { SystemConfigurationService } from './api/systemConfiguration.service';\nimport { TableService } from './api/table.service';\nimport { WarEntityPreviewControllerService } from './api/warEntityPreviewController.service';\n\n@NgModule({\n  imports:      [],\n  declarations: [],\n  exports:      [],\n  providers: []\n})\nexport class ApiModule {\n    public static forRoot(configurationFactory: () => Configuration): ModuleWithProviders {\n        return {\n            ngModule: ApiModule,\n            providers: [ { provide: Configuration, useFactory: configurationFactory } ]\n        };\n    }\n\n    constructor( @Optional() @SkipSelf() parentModule: ApiModule,\n                 @Optional() http: HttpClient) {\n        if (parentModule) {\n            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\n        }\n        if (!http) {\n            throw new Error('You need to import the HttpClientModule in your AppModule! \\n' +\n            'See also https://github.com/angular/angular/issues/20575');\n        }\n    }\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n\n/**\n * Custom HttpParameterCodec\n * Workaround for https://github.com/angular/angular/issues/18261\n */\nexport class CustomHttpParameterCodec implements HttpParameterCodec {\n    encodeKey(k: string): string {\n        return encodeURIComponent(k);\n    }\n    encodeValue(v: string): string {\n        return encodeURIComponent(v);\n    }\n    decodeKey(k: string): string {\n        return decodeURIComponent(k);\n    }\n    decodeValue(v: string): string {\n        return decodeURIComponent(v);\n    }\n}\n","import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { HttpErrorModel } from '../model/models';\nimport { LoginRequest } from '../model/models';\nimport { LoginResponse } from '../model/models';\nimport { ResetPasswordRequest } from '../model/models';\nimport { ResponseWithMsg } from '../model/models';\nimport { SignupRequest } from '../model/models';\nimport { SignupResponse } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AccountService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param email \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public accountControllerForgotPassword(email: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<ResponseWithMsg>;\n    public accountControllerForgotPassword(email: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<ResponseWithMsg>>;\n    public accountControllerForgotPassword(email: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<ResponseWithMsg>>;\n    public accountControllerForgotPassword(email: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n        if (email === null || email === undefined) {\n            throw new Error('Required parameter email was null or undefined when calling accountControllerForgotPassword.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (email !== undefined && email !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>email, 'email');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<ResponseWithMsg>(`${this.configuration.basePath}/forgot-password`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Login with existing account\n     * @param loginRequest \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public accountControllerLogin(loginRequest?: LoginRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<LoginResponse>;\n    public accountControllerLogin(loginRequest?: LoginRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<LoginResponse>>;\n    public accountControllerLogin(loginRequest?: LoginRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<LoginResponse>>;\n    public accountControllerLogin(loginRequest?: LoginRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<LoginResponse>(`${this.configuration.basePath}/login`,\n            loginRequest,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param resetPasswordRequest \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public accountControllerResetPassword(resetPasswordRequest?: ResetPasswordRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<ResponseWithMsg>;\n    public accountControllerResetPassword(resetPasswordRequest?: ResetPasswordRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<ResponseWithMsg>>;\n    public accountControllerResetPassword(resetPasswordRequest?: ResetPasswordRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<ResponseWithMsg>>;\n    public accountControllerResetPassword(resetPasswordRequest?: ResetPasswordRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<ResponseWithMsg>(`${this.configuration.basePath}/reset-password`,\n            resetPasswordRequest,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Sign up / register new account\n     * @param signupRequest \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public accountControllerSignUp(signupRequest?: SignupRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<SignupResponse>;\n    public accountControllerSignUp(signupRequest?: SignupRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<SignupResponse>>;\n    public accountControllerSignUp(signupRequest?: SignupRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<SignupResponse>>;\n    public accountControllerSignUp(signupRequest?: SignupRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<SignupResponse>(`${this.configuration.basePath}/signup`,\n            signupRequest,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Verifies email address. Usually needed to complete registration of new account.\n     * @param accountId \n     * @param verificationToken \n     * @param redirectOnSuccess \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public accountControllerVerifyEmail(accountId?: number, verificationToken?: string, redirectOnSuccess?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public accountControllerVerifyEmail(accountId?: number, verificationToken?: string, redirectOnSuccess?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public accountControllerVerifyEmail(accountId?: number, verificationToken?: string, redirectOnSuccess?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public accountControllerVerifyEmail(accountId?: number, verificationToken?: string, redirectOnSuccess?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (accountId !== undefined && accountId !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>accountId, 'accountId');\n        }\n        if (verificationToken !== undefined && verificationToken !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>verificationToken, 'verificationToken');\n        }\n        if (redirectOnSuccess !== undefined && redirectOnSuccess !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>redirectOnSuccess, 'redirectOnSuccess');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<any>(`${this.configuration.basePath}/verify-email`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Decodes the given token and returns the user id.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public accountControllerWhoAmI(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<string>;\n    public accountControllerWhoAmI(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<string>>;\n    public accountControllerWhoAmI(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<string>>;\n    public accountControllerWhoAmI(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<string>(`${this.configuration.basePath}/whoAmI`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { AnalysisMapRequest } from '../model/models';\nimport { AnalysisMapResponse } from '../model/models';\nimport { AnalysisTableExportRequest } from '../model/models';\nimport { AnalysisTableExportResponse } from '../model/models';\nimport { AnalysisTableRequest } from '../model/models';\nimport { AnalysisTableResponse } from '../model/models';\nimport { AnalysisTimeChartRequest } from '../model/models';\nimport { AnalysisTimeChartResponse } from '../model/models';\nimport { GvSchemaObject } from '../model/models';\nimport { ProAnalysis } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AnalysisService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param pkProject \n     * @param requestBody \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public analysisControllerBulkDelete(pkProject?: number, requestBody?: Array<number>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public analysisControllerBulkDelete(pkProject?: number, requestBody?: Array<number>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public analysisControllerBulkDelete(pkProject?: number, requestBody?: Array<number>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public analysisControllerBulkDelete(pkProject?: number, requestBody?: Array<number>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<any>(`${this.configuration.basePath}/analysis/bulk-delete`,\n            requestBody,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update or insert array of ProAnalysis of a project.\n     * @param pkProject \n     * @param proAnalysis \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public analysisControllerBulkUpsert(pkProject?: number, proAnalysis?: Array<ProAnalysis>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GvSchemaObject>;\n    public analysisControllerBulkUpsert(pkProject?: number, proAnalysis?: Array<ProAnalysis>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GvSchemaObject>>;\n    public analysisControllerBulkUpsert(pkProject?: number, proAnalysis?: Array<ProAnalysis>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GvSchemaObject>>;\n    public analysisControllerBulkUpsert(pkProject?: number, proAnalysis?: Array<ProAnalysis>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<GvSchemaObject>(`${this.configuration.basePath}/analysis/bulk-upsert`,\n            proAnalysis,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a ProAnalysis version. If no version specified, latest version is returned.\n     * @param pkProject \n     * @param pkEntity \n     * @param version \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public analysisControllerGetVersion(pkProject?: number, pkEntity?: number, version?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GvSchemaObject>;\n    public analysisControllerGetVersion(pkProject?: number, pkEntity?: number, version?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GvSchemaObject>>;\n    public analysisControllerGetVersion(pkProject?: number, pkEntity?: number, version?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GvSchemaObject>>;\n    public analysisControllerGetVersion(pkProject?: number, pkEntity?: number, version?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n        if (version !== undefined && version !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>version, 'version');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<GvSchemaObject>(`${this.configuration.basePath}/analysis/get-version`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Run the analysis of type map\n     * @param analysisMapRequest \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public analysisControllerMapRun(analysisMapRequest?: AnalysisMapRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<AnalysisMapResponse>;\n    public analysisControllerMapRun(analysisMapRequest?: AnalysisMapRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<AnalysisMapResponse>>;\n    public analysisControllerMapRun(analysisMapRequest?: AnalysisMapRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<AnalysisMapResponse>>;\n    public analysisControllerMapRun(analysisMapRequest?: AnalysisMapRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<AnalysisMapResponse>(`${this.configuration.basePath}/analysis/map-run`,\n            analysisMapRequest,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get all ProAnalysis of a project.\n     * @param pkProject \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public analysisControllerOfProject(pkProject: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GvSchemaObject>;\n    public analysisControllerOfProject(pkProject: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GvSchemaObject>>;\n    public analysisControllerOfProject(pkProject: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GvSchemaObject>>;\n    public analysisControllerOfProject(pkProject: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling analysisControllerOfProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<GvSchemaObject>(`${this.configuration.basePath}/analysis/of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Export the analysis of type table\n     * @param analysisTableExportRequest \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public analysisControllerTableExport(analysisTableExportRequest?: AnalysisTableExportRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<AnalysisTableExportResponse>;\n    public analysisControllerTableExport(analysisTableExportRequest?: AnalysisTableExportRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<AnalysisTableExportResponse>>;\n    public analysisControllerTableExport(analysisTableExportRequest?: AnalysisTableExportRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<AnalysisTableExportResponse>>;\n    public analysisControllerTableExport(analysisTableExportRequest?: AnalysisTableExportRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<AnalysisTableExportResponse>(`${this.configuration.basePath}/analysis/table-export`,\n            analysisTableExportRequest,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Run the analysis of type table\n     * @param analysisTableRequest \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public analysisControllerTableRun(analysisTableRequest?: AnalysisTableRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<AnalysisTableResponse>;\n    public analysisControllerTableRun(analysisTableRequest?: AnalysisTableRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<AnalysisTableResponse>>;\n    public analysisControllerTableRun(analysisTableRequest?: AnalysisTableRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<AnalysisTableResponse>>;\n    public analysisControllerTableRun(analysisTableRequest?: AnalysisTableRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<AnalysisTableResponse>(`${this.configuration.basePath}/analysis/table-run`,\n            analysisTableRequest,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Run the analysis of type time-chart\n     * @param analysisTimeChartRequest \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public analysisControllerTimeChartRun(analysisTimeChartRequest?: AnalysisTimeChartRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<AnalysisTimeChartResponse>;\n    public analysisControllerTimeChartRun(analysisTimeChartRequest?: AnalysisTimeChartRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<AnalysisTimeChartResponse>>;\n    public analysisControllerTimeChartRun(analysisTimeChartRequest?: AnalysisTimeChartRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<AnalysisTimeChartResponse>>;\n    public analysisControllerTimeChartRun(analysisTimeChartRequest?: AnalysisTimeChartRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<AnalysisTimeChartResponse>(`${this.configuration.basePath}/analysis/time-chart-run`,\n            analysisTimeChartRequest,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { GvSchemaObject } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ContentTreeService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get SchemaObject with everything needed to build the tree of the content of an F2 Expression.\n     * @param pkProject Primary key of the project\n     * @param pkExpressionEntity Primary Key of the F2 Expression entity for which the content tree is needed.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public contentTreeControllerGetContentTree(pkProject: number, pkExpressionEntity: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GvSchemaObject>;\n    public contentTreeControllerGetContentTree(pkProject: number, pkExpressionEntity: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GvSchemaObject>>;\n    public contentTreeControllerGetContentTree(pkProject: number, pkExpressionEntity: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GvSchemaObject>>;\n    public contentTreeControllerGetContentTree(pkProject: number, pkExpressionEntity: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling contentTreeControllerGetContentTree.');\n        }\n        if (pkExpressionEntity === null || pkExpressionEntity === undefined) {\n            throw new Error('Required parameter pkExpressionEntity was null or undefined when calling contentTreeControllerGetContentTree.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkExpressionEntity !== undefined && pkExpressionEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkExpressionEntity, 'pkExpressionEntity');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<GvSchemaObject>(`${this.configuration.basePath}/get-content-tree`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DatChunk } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DatChunkService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Find a model instance by {{id}} from the data source.\n     * @param id Model id\n     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\\&quot;something\\&quot;:\\&quot;value\\&quot;})\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datChunkFindById(id: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<DatChunk>;\n    public datChunkFindById(id: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<DatChunk>>;\n    public datChunkFindById(id: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<DatChunk>>;\n    public datChunkFindById(id: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling datChunkFindById.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<DatChunk>(`${this.configuration.basePath}/lb3-api/DatChunks/${encodeURIComponent(String(id))}`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the chunks related to the digital, with their statements.\n     * @param pkProject Primary key of the project\n     * @param pkDigital Primary key of the digital\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datChunkOfDigital(pkProject: number, pkDigital: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<DatChunk>>;\n    public datChunkOfDigital(pkProject: number, pkDigital: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<DatChunk>>>;\n    public datChunkOfDigital(pkProject: number, pkDigital: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<DatChunk>>>;\n    public datChunkOfDigital(pkProject: number, pkDigital: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling datChunkOfDigital.');\n        }\n        if (pkDigital === null || pkDigital === undefined) {\n            throw new Error('Required parameter pkDigital was null or undefined when calling datChunkOfDigital.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkDigital !== undefined && pkDigital !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkDigital, 'pkDigital');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<DatChunk>>(`${this.configuration.basePath}/lb3-api/DatChunks/of-digital`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DatChunkFilter } from '../model/models';\nimport { DatChunkWithRelations } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DatChunkControllerService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param id \n     * @param filter \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datChunkControllerFindById(id: number, filter?: DatChunkFilter, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<DatChunkWithRelations>;\n    public datChunkControllerFindById(id: number, filter?: DatChunkFilter, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<DatChunkWithRelations>>;\n    public datChunkControllerFindById(id: number, filter?: DatChunkFilter, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<DatChunkWithRelations>>;\n    public datChunkControllerFindById(id: number, filter?: DatChunkFilter, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling datChunkControllerFindById.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<DatChunkWithRelations>(`${this.configuration.basePath}/dat-chunks/${encodeURIComponent(String(id))}`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DatColumn } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DatColumnService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get the columns related to the digital (table).\n     * @param pkProject Primary key of the project\n     * @param pkDigital Primary key of the digital\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datColumnOfDigital(pkProject: number, pkDigital: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<DatColumn>>;\n    public datColumnOfDigital(pkProject: number, pkDigital: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<DatColumn>>>;\n    public datColumnOfDigital(pkProject: number, pkDigital: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<DatColumn>>>;\n    public datColumnOfDigital(pkProject: number, pkDigital: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling datColumnOfDigital.');\n        }\n        if (pkDigital === null || pkDigital === undefined) {\n            throw new Error('Required parameter pkDigital was null or undefined when calling datColumnOfDigital.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkDigital !== undefined && pkDigital !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkDigital, 'pkDigital');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<DatColumn>>(`${this.configuration.basePath}/lb3-api/DatColumns/of-digital`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DatDigital } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DatDigitalService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Deletes instances of DatDigital.\n     * @param requestBody Array of Primary Key of DatDigitals\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datDigitalBulkDelete(requestBody: Array<number>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<boolean>;\n    public datDigitalBulkDelete(requestBody: Array<number>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<boolean>>;\n    public datDigitalBulkDelete(requestBody: Array<number>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<boolean>>;\n    public datDigitalBulkDelete(requestBody: Array<number>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (requestBody === null || requestBody === undefined) {\n            throw new Error('Required parameter requestBody was null or undefined when calling datDigitalBulkDelete.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<boolean>(`${this.configuration.basePath}/lb3-api/DatDigitals/delete-delete`,\n            requestBody,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates or updates instances of DatDigital.\n     * @param pkNamespace Namespace\n     * @param datDigital Array DatDigital\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datDigitalBulkUpsert(pkNamespace: number, datDigital: Array<DatDigital>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<DatDigital>;\n    public datDigitalBulkUpsert(pkNamespace: number, datDigital: Array<DatDigital>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<DatDigital>>;\n    public datDigitalBulkUpsert(pkNamespace: number, datDigital: Array<DatDigital>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<DatDigital>>;\n    public datDigitalBulkUpsert(pkNamespace: number, datDigital: Array<DatDigital>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkNamespace === null || pkNamespace === undefined) {\n            throw new Error('Required parameter pkNamespace was null or undefined when calling datDigitalBulkUpsert.');\n        }\n        if (datDigital === null || datDigital === undefined) {\n            throw new Error('Required parameter datDigital was null or undefined when calling datDigitalBulkUpsert.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkNamespace !== undefined && pkNamespace !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkNamespace, 'pkNamespace');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<DatDigital>(`${this.configuration.basePath}/lb3-api/DatDigitals/bulk-upsert`,\n            datDigital,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find a model instance by {{id}} from the data source.\n     * @param id Model id\n     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\\&quot;something\\&quot;:\\&quot;value\\&quot;})\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datDigitalFindById(id: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<DatDigital>;\n    public datDigitalFindById(id: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<DatDigital>>;\n    public datDigitalFindById(id: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<DatDigital>>;\n    public datDigitalFindById(id: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling datDigitalFindById.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<DatDigital>(`${this.configuration.basePath}/lb3-api/DatDigitals/${encodeURIComponent(String(id))}`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get page of table\n     * @param pkProject Pk of the project.\n     * @param pkEntity Pk of the table digital.\n     * @param body options\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datDigitalGetTablePage(pkProject: number, pkEntity: number, body?: object, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<object>>;\n    public datDigitalGetTablePage(pkProject: number, pkEntity: number, body?: object, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<object>>>;\n    public datDigitalGetTablePage(pkProject: number, pkEntity: number, body?: object, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<object>>>;\n    public datDigitalGetTablePage(pkProject: number, pkEntity: number, body?: object, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling datDigitalGetTablePage.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling datDigitalGetTablePage.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<object>>(`${this.configuration.basePath}/lb3-api/DatDigitals/getTablePage`,\n            body,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Finds the version of given digital. If no version specified, latest is returned.\n     * @param pkEntity Primary Key of the digital object (pk_entity)\n     * @param entityVersion Primary Key of the digital object (entity_version)\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datDigitalGetVersion(pkEntity: number, entityVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<DatDigital>>;\n    public datDigitalGetVersion(pkEntity: number, entityVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<DatDigital>>>;\n    public datDigitalGetVersion(pkEntity: number, entityVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<DatDigital>>>;\n    public datDigitalGetVersion(pkEntity: number, entityVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling datDigitalGetVersion.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n        if (entityVersion !== undefined && entityVersion !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>entityVersion, 'entityVersion');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<DatDigital>>(`${this.configuration.basePath}/lb3-api/DatDigitals/get-version`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DatNamespace } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DatNamespaceService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Finds namespaces of a project.\n     * @param pkProject Key of the Project for which the namespaces should be found.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datNamespaceByProject(pkProject: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<DatNamespace>>;\n    public datNamespaceByProject(pkProject: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<DatNamespace>>>;\n    public datNamespaceByProject(pkProject: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<DatNamespace>>>;\n    public datNamespaceByProject(pkProject: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling datNamespaceByProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<DatNamespace>>(`${this.configuration.basePath}/lb3-api/DatNamespaces/find-by-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find all instances of the model matched by filter from the data source.\n     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\\&quot;where\\&quot;:{\\&quot;something\\&quot;:\\&quot;value\\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datNamespaceFind(filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<DatNamespace>>;\n    public datNamespaceFind(filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<DatNamespace>>>;\n    public datNamespaceFind(filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<DatNamespace>>>;\n    public datNamespaceFind(filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<DatNamespace>>(`${this.configuration.basePath}/lb3-api/DatNamespaces`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find a model instance by {{id}} from the data source.\n     * @param id Model id\n     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\\&quot;something\\&quot;:\\&quot;value\\&quot;})\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public datNamespaceFindById(id: string, filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<DatNamespace>;\n    public datNamespaceFindById(id: string, filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<DatNamespace>>;\n    public datNamespaceFindById(id: string, filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<DatNamespace>>;\n    public datNamespaceFindById(id: string, filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling datNamespaceFindById.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<DatNamespace>(`${this.configuration.basePath}/lb3-api/DatNamespaces/${encodeURIComponent(String(id))}`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DfhClass } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DfhClassControllerService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param pkProject \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public dfhClassControllerOfProject(pkProject?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<Array<DfhClass>>;\n    public dfhClassControllerOfProject(pkProject?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<Array<DfhClass>>>;\n    public dfhClassControllerOfProject(pkProject?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<Array<DfhClass>>>;\n    public dfhClassControllerOfProject(pkProject?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<DfhClass>>(`${this.configuration.basePath}/classes/of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DfhLabel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DfhLabelService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get all dfh labels needed by the given project.\n     * @param pkProject Project pk\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public dfhLabelOfProject(pkProject?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<DfhLabel>>;\n    public dfhLabelOfProject(pkProject?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<DfhLabel>>>;\n    public dfhLabelOfProject(pkProject?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<DfhLabel>>>;\n    public dfhLabelOfProject(pkProject?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<DfhLabel>>(`${this.configuration.basePath}/lb3-api/DfhLabels/of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DfhProfile } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DfhProfileService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Deavtivates an OntoMe profile for a Geovistory project.\n     * @param pkProject Geovistory project for which the profile should be deactivated\n     * @param pkProfile OntoMe profile to deactivate for the given Geovistory project\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public dfhProfileDeactivateProfileForProject(pkProject: number, pkProfile: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<object>>;\n    public dfhProfileDeactivateProfileForProject(pkProject: number, pkProfile: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<object>>>;\n    public dfhProfileDeactivateProfileForProject(pkProject: number, pkProfile: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<object>>>;\n    public dfhProfileDeactivateProfileForProject(pkProject: number, pkProfile: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling dfhProfileDeactivateProfileForProject.');\n        }\n        if (pkProfile === null || pkProfile === undefined) {\n            throw new Error('Required parameter pkProfile was null or undefined when calling dfhProfileDeactivateProfileForProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkProfile !== undefined && pkProfile !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProfile, 'pkProfile');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<object>>(`${this.configuration.basePath}/lb3-api/DfhProfiles/deactivate-ontome-profile-for-geovistory-project`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates an activation report for the given OntoMe profile and the given Geovistory project.\n     * @param pkProject Geovistory project for which the activation report should be created\n     * @param pkProfile OntoMe profile for which the activation report should be created\n     * @param requestedLanguage Language ISO Code for the preferred language of labels and descriptions to be loaded. Default language is \\&#39;en\\&#39;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public dfhProfileGetActivationReport(pkProject: number, pkProfile: number, requestedLanguage?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<object>>;\n    public dfhProfileGetActivationReport(pkProject: number, pkProfile: number, requestedLanguage?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<object>>>;\n    public dfhProfileGetActivationReport(pkProject: number, pkProfile: number, requestedLanguage?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<object>>>;\n    public dfhProfileGetActivationReport(pkProject: number, pkProfile: number, requestedLanguage?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling dfhProfileGetActivationReport.');\n        }\n        if (pkProfile === null || pkProfile === undefined) {\n            throw new Error('Required parameter pkProfile was null or undefined when calling dfhProfileGetActivationReport.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkProfile !== undefined && pkProfile !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProfile, 'pkProfile');\n        }\n        if (requestedLanguage !== undefined && requestedLanguage !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>requestedLanguage, 'requestedLanguage');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<object>>(`${this.configuration.basePath}/lb3-api/DfhProfiles/get-activation-report`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates an deactivation report for the given OntoMe profile and the given Geovistory project.\n     * @param pkProject Geovistory project for which the deactivation report should be created\n     * @param pkProfile OntoMe profile for which the deactivation report should be created\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public dfhProfileGetDeactivationReport(pkProject: number, pkProfile: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<object>>;\n    public dfhProfileGetDeactivationReport(pkProject: number, pkProfile: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<object>>>;\n    public dfhProfileGetDeactivationReport(pkProject: number, pkProfile: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<object>>>;\n    public dfhProfileGetDeactivationReport(pkProject: number, pkProfile: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling dfhProfileGetDeactivationReport.');\n        }\n        if (pkProfile === null || pkProfile === undefined) {\n            throw new Error('Required parameter pkProfile was null or undefined when calling dfhProfileGetDeactivationReport.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkProfile !== undefined && pkProfile !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProfile, 'pkProfile');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<object>>(`${this.configuration.basePath}/lb3-api/DfhProfiles/get-deactivation-report`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get all profiles that are used by the given project.\n     * @param pkProject Project pk\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public dfhProfileOfProject(pkProject?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<DfhProfile>>;\n    public dfhProfileOfProject(pkProject?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<DfhProfile>>>;\n    public dfhProfileOfProject(pkProject?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<DfhProfile>>>;\n    public dfhProfileOfProject(pkProject?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<DfhProfile>>(`${this.configuration.basePath}/lb3-api/DfhProfiles/of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Pulls profile data including classes and properties from OntoMe andadds profile to project.\n     * @param pkProject Geovistory project to which the OntoMe profile should be added\n     * @param pkProfile OntoMe profile that should be added\n     * @param requestedLanguage Language ISO Code for the preferred language of labels and descriptions to be loaded. Default language is \\&#39;en\\&#39;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public dfhProfileUpdateAndAddToProject(pkProject: number, pkProfile: number, requestedLanguage?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<object>>;\n    public dfhProfileUpdateAndAddToProject(pkProject: number, pkProfile: number, requestedLanguage?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<object>>>;\n    public dfhProfileUpdateAndAddToProject(pkProject: number, pkProfile: number, requestedLanguage?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<object>>>;\n    public dfhProfileUpdateAndAddToProject(pkProject: number, pkProfile: number, requestedLanguage?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling dfhProfileUpdateAndAddToProject.');\n        }\n        if (pkProfile === null || pkProfile === undefined) {\n            throw new Error('Required parameter pkProfile was null or undefined when calling dfhProfileUpdateAndAddToProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkProfile !== undefined && pkProfile !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProfile, 'pkProfile');\n        }\n        if (requestedLanguage !== undefined && requestedLanguage !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>requestedLanguage, 'requestedLanguage');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<object>>(`${this.configuration.basePath}/lb3-api/DfhProfiles/update-from-ontome-and-add-to-project`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Pulls profile data including classes and properties from OntoMe and updates profile data in geovistory.\n     * @param pkProfile OntoMe profile that should be added\n     * @param requestedLanguage Language ISO Code for the preferred language of labels and descriptions to be loaded. Default language is \\&#39;en\\&#39;.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public dfhProfileUpdateFromOntoMe(pkProfile: number, requestedLanguage?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<object>>;\n    public dfhProfileUpdateFromOntoMe(pkProfile: number, requestedLanguage?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<object>>>;\n    public dfhProfileUpdateFromOntoMe(pkProfile: number, requestedLanguage?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<object>>>;\n    public dfhProfileUpdateFromOntoMe(pkProfile: number, requestedLanguage?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProfile === null || pkProfile === undefined) {\n            throw new Error('Required parameter pkProfile was null or undefined when calling dfhProfileUpdateFromOntoMe.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProfile !== undefined && pkProfile !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProfile, 'pkProfile');\n        }\n        if (requestedLanguage !== undefined && requestedLanguage !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>requestedLanguage, 'requestedLanguage');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<object>>(`${this.configuration.basePath}/lb3-api/DfhProfiles/update-from-ontome`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { DfhProperty } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DfhPropertyControllerService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param pkProject \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public dfhPropertyControllerOfProject(pkProject?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<Array<DfhProperty>>;\n    public dfhPropertyControllerOfProject(pkProject?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<Array<DfhProperty>>>;\n    public dfhPropertyControllerOfProject(pkProject?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<Array<DfhProperty>>>;\n    public dfhPropertyControllerOfProject(pkProject?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<DfhProperty>>(`${this.configuration.basePath}/properties/of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { GetFactoidsFromEntityResponse } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class FactoidControllerService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Fetch all factoids about an entity\n     * @param pkProject \n     * @param pkEntity \n     * @param factoidNumber \n     * @param page \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public factoidControllerFactoidsFromEntity(pkProject: string, pkEntity: string, factoidNumber: string, page: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GetFactoidsFromEntityResponse>;\n    public factoidControllerFactoidsFromEntity(pkProject: string, pkEntity: string, factoidNumber: string, page: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GetFactoidsFromEntityResponse>>;\n    public factoidControllerFactoidsFromEntity(pkProject: string, pkEntity: string, factoidNumber: string, page: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GetFactoidsFromEntityResponse>>;\n    public factoidControllerFactoidsFromEntity(pkProject: string, pkEntity: string, factoidNumber: string, page: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling factoidControllerFactoidsFromEntity.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling factoidControllerFactoidsFromEntity.');\n        }\n        if (factoidNumber === null || factoidNumber === undefined) {\n            throw new Error('Required parameter factoidNumber was null or undefined when calling factoidControllerFactoidsFromEntity.');\n        }\n        if (page === null || page === undefined) {\n            throw new Error('Required parameter page was null or undefined when calling factoidControllerFactoidsFromEntity.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n        if (factoidNumber !== undefined && factoidNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>factoidNumber, 'factoidNumber');\n        }\n        if (page !== undefined && page !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>page, 'page');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<GetFactoidsFromEntityResponse>(`${this.configuration.basePath}/get-factoids-from-entity`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ImportTable } from '../model/models';\nimport { ImportTableResponse } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ImportTableControllerService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param pkNamespace \n     * @param importTable \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public importTableControllerImportTable(pkNamespace?: number, importTable?: ImportTable, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<ImportTableResponse>;\n    public importTableControllerImportTable(pkNamespace?: number, importTable?: ImportTable, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<ImportTableResponse>>;\n    public importTableControllerImportTable(pkNamespace?: number, importTable?: ImportTable, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<ImportTableResponse>>;\n    public importTableControllerImportTable(pkNamespace?: number, importTable?: ImportTable, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkNamespace !== undefined && pkNamespace !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkNamespace, 'pkNamespace');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<ImportTableResponse>(`${this.configuration.basePath}/import-table`,\n            importTable,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { InfLanguage } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class InfLanguageService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Find all instances of the model matched by filter from the data source.\n     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\\&quot;where\\&quot;:{\\&quot;something\\&quot;:\\&quot;value\\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infLanguageFind(filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfLanguage>>;\n    public infLanguageFind(filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfLanguage>>>;\n    public infLanguageFind(filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfLanguage>>>;\n    public infLanguageFind(filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<InfLanguage>>(`${this.configuration.basePath}/lb3-api/InfLanguages`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Perform a ranked search on languages by search string.\n     * @param queryString \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infLanguageQueryByString(queryString?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfLanguage>>;\n    public infLanguageQueryByString(queryString?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfLanguage>>>;\n    public infLanguageQueryByString(queryString?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfLanguage>>>;\n    public infLanguageQueryByString(queryString?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (queryString !== undefined && queryString !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>queryString, 'queryString');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<InfLanguage>>(`${this.configuration.basePath}/lb3-api/InfLanguages/query-by-string`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { InfPersistentItem } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class InfPersistentItemService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Find or create many information persistent items.\n     * @param pkProject Pk of the project\n     * @param infPersistentItem data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infPersistentItemFindOrCreateInfPersistentItems(pkProject: number, infPersistentItem: Array<InfPersistentItem>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfPersistentItem>>;\n    public infPersistentItemFindOrCreateInfPersistentItems(pkProject: number, infPersistentItem: Array<InfPersistentItem>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfPersistentItem>>>;\n    public infPersistentItemFindOrCreateInfPersistentItems(pkProject: number, infPersistentItem: Array<InfPersistentItem>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfPersistentItem>>>;\n    public infPersistentItemFindOrCreateInfPersistentItems(pkProject: number, infPersistentItem: Array<InfPersistentItem>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infPersistentItemFindOrCreateInfPersistentItems.');\n        }\n        if (infPersistentItem === null || infPersistentItem === undefined) {\n            throw new Error('Required parameter infPersistentItem was null or undefined when calling infPersistentItemFindOrCreateInfPersistentItems.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pk_project');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<InfPersistentItem>>(`${this.configuration.basePath}/lb3-api/InfPersistentItems/find-or-create-many`,\n            infPersistentItem,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get only miminal properties of persistent item.\n     * @param pkProject Pk of the project.\n     * @param pkEntity Pk of the entity.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infPersistentItemOwnProperties(pkProject: number, pkEntity: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<object>;\n    public infPersistentItemOwnProperties(pkProject: number, pkEntity: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<object>>;\n    public infPersistentItemOwnProperties(pkProject: number, pkEntity: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<object>>;\n    public infPersistentItemOwnProperties(pkProject: number, pkEntity: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infPersistentItemOwnProperties.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling infPersistentItemOwnProperties.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<object>(`${this.configuration.basePath}/lb3-api/InfPersistentItems/own-properties`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find one type by pk_entitywith appellations and text properties.\n     * @param pkProject Primary Key of Project\n     * @param pkEntity Primary Key of the type. Provide this if you want to query one specific type.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infPersistentItemTypeNested(pkProject: number, pkEntity: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<InfPersistentItem>;\n    public infPersistentItemTypeNested(pkProject: number, pkEntity: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<InfPersistentItem>>;\n    public infPersistentItemTypeNested(pkProject: number, pkEntity: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<InfPersistentItem>>;\n    public infPersistentItemTypeNested(pkProject: number, pkEntity: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infPersistentItemTypeNested.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling infPersistentItemTypeNested.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pk_project');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pk_entity');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<InfPersistentItem>(`${this.configuration.basePath}/lb3-api/InfPersistentItems/type-nested`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find types of typed class and project. E.g. get the types for the class \\&#39;histC8 Geographical Place\\&#39; (pk_typed_class&#x3D;363) used in project (pk_project&#x3D;123)\n     * @param pkProject Primary Key of Project\n     * @param pkTypedClasses Primary Keyes of Typed Classes (e.g. pk of Geographical Place to get Geographical Place Types)\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infPersistentItemTypesOfClassesAndProject(pkProject: number, pkTypedClasses: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<InfPersistentItem>;\n    public infPersistentItemTypesOfClassesAndProject(pkProject: number, pkTypedClasses: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<InfPersistentItem>>;\n    public infPersistentItemTypesOfClassesAndProject(pkProject: number, pkTypedClasses: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<InfPersistentItem>>;\n    public infPersistentItemTypesOfClassesAndProject(pkProject: number, pkTypedClasses: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infPersistentItemTypesOfClassesAndProject.');\n        }\n        if (pkTypedClasses === null || pkTypedClasses === undefined) {\n            throw new Error('Required parameter pkTypedClasses was null or undefined when calling infPersistentItemTypesOfClassesAndProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pk_project');\n        }\n        if (pkTypedClasses !== undefined && pkTypedClasses !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkTypedClasses, 'pk_typed_classes');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<InfPersistentItem>(`${this.configuration.basePath}/lb3-api/InfPersistentItems/types-of-classes-and-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a minimal nested object of all types in the project.\n     * @param pkProject Pk of the project.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infPersistentItemTypesOfProject(pkProject: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<InfPersistentItem>;\n    public infPersistentItemTypesOfProject(pkProject: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<InfPersistentItem>>;\n    public infPersistentItemTypesOfProject(pkProject: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<InfPersistentItem>>;\n    public infPersistentItemTypesOfProject(pkProject: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infPersistentItemTypesOfProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<InfPersistentItem>(`${this.configuration.basePath}/lb3-api/InfPersistentItems/types-of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { InfPlace } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class InfPlaceService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Find all instances of the model matched by filter from the data source.\n     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\\&quot;where\\&quot;:{\\&quot;something\\&quot;:\\&quot;value\\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infPlaceFind(filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfPlace>>;\n    public infPlaceFind(filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfPlace>>>;\n    public infPlaceFind(filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfPlace>>>;\n    public infPlaceFind(filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<InfPlace>>(`${this.configuration.basePath}/lb3-api/InfPlaces`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find or create a InfPlace and update the project relation if needed.\n     * @param projectId Id of the project\n     * @param infPlace data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infPlaceFindOrCreatePlace(projectId: number, infPlace: InfPlace, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<InfPlace>;\n    public infPlaceFindOrCreatePlace(projectId: number, infPlace: InfPlace, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<InfPlace>>;\n    public infPlaceFindOrCreatePlace(projectId: number, infPlace: InfPlace, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<InfPlace>>;\n    public infPlaceFindOrCreatePlace(projectId: number, infPlace: InfPlace, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (projectId === null || projectId === undefined) {\n            throw new Error('Required parameter projectId was null or undefined when calling infPlaceFindOrCreatePlace.');\n        }\n        if (infPlace === null || infPlace === undefined) {\n            throw new Error('Required parameter infPlace was null or undefined when calling infPlaceFindOrCreatePlace.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (projectId !== undefined && projectId !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>projectId, 'projectId');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<InfPlace>(`${this.configuration.basePath}/lb3-api/InfPlaces/findOrCreate`,\n            infPlace,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { InfStatement } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class InfStatementService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get statements (with children) of given fkProperty and fkEntity from Repo that are not in project of given projectId.\n     * @param entityPk Key of the persistent item (fk_object_info)\n     * @param propertyPk Key of the property (fk_property)\n     * @param pkProject Id of the the current project\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infStatementAlternativesNotInProjectByEntityPk(entityPk: number, propertyPk: number, pkProject: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfStatement>>;\n    public infStatementAlternativesNotInProjectByEntityPk(entityPk: number, propertyPk: number, pkProject: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfStatement>>>;\n    public infStatementAlternativesNotInProjectByEntityPk(entityPk: number, propertyPk: number, pkProject: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfStatement>>>;\n    public infStatementAlternativesNotInProjectByEntityPk(entityPk: number, propertyPk: number, pkProject: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (entityPk === null || entityPk === undefined) {\n            throw new Error('Required parameter entityPk was null or undefined when calling infStatementAlternativesNotInProjectByEntityPk.');\n        }\n        if (propertyPk === null || propertyPk === undefined) {\n            throw new Error('Required parameter propertyPk was null or undefined when calling infStatementAlternativesNotInProjectByEntityPk.');\n        }\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infStatementAlternativesNotInProjectByEntityPk.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (entityPk !== undefined && entityPk !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>entityPk, 'entityPk');\n        }\n        if (propertyPk !== undefined && propertyPk !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>propertyPk, 'propertyPk');\n        }\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<InfStatement>>(`${this.configuration.basePath}/lb3-api/InfStatements/alternatives-not-in-project-by-entity-pk`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get statements (with children) of given propertyPk and teEntPk from Repo that are not in project of given projectId.\n     * @param teEntPk Key of the temporal entity (fk_subject_info)\n     * @param propertyPk Key of the property (fk_property)\n     * @param pkProject Id of the the current project\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infStatementAlternativesNotInProjectByTeEntPk(teEntPk: number, propertyPk: number, pkProject: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfStatement>>;\n    public infStatementAlternativesNotInProjectByTeEntPk(teEntPk: number, propertyPk: number, pkProject: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfStatement>>>;\n    public infStatementAlternativesNotInProjectByTeEntPk(teEntPk: number, propertyPk: number, pkProject: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfStatement>>>;\n    public infStatementAlternativesNotInProjectByTeEntPk(teEntPk: number, propertyPk: number, pkProject: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (teEntPk === null || teEntPk === undefined) {\n            throw new Error('Required parameter teEntPk was null or undefined when calling infStatementAlternativesNotInProjectByTeEntPk.');\n        }\n        if (propertyPk === null || propertyPk === undefined) {\n            throw new Error('Required parameter propertyPk was null or undefined when calling infStatementAlternativesNotInProjectByTeEntPk.');\n        }\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infStatementAlternativesNotInProjectByTeEntPk.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (teEntPk !== undefined && teEntPk !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>teEntPk, 'teEntPk');\n        }\n        if (propertyPk !== undefined && propertyPk !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>propertyPk, 'propertyPk');\n        }\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<InfStatement>>(`${this.configuration.basePath}/lb3-api/InfStatements/alternatives-not-in-project-by-te-ent-pk`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find or create information statement.\n     * @param pkProject Id of the project\n     * @param infStatement data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infStatementFindOrCreateInfStatements(pkProject: number, infStatement: Array<InfStatement>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfStatement>>;\n    public infStatementFindOrCreateInfStatements(pkProject: number, infStatement: Array<InfStatement>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfStatement>>>;\n    public infStatementFindOrCreateInfStatements(pkProject: number, infStatement: Array<InfStatement>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfStatement>>>;\n    public infStatementFindOrCreateInfStatements(pkProject: number, infStatement: Array<InfStatement>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infStatementFindOrCreateInfStatements.');\n        }\n        if (infStatement === null || infStatement === undefined) {\n            throw new Error('Required parameter infStatement was null or undefined when calling infStatementFindOrCreateInfStatements.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pk_project');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<InfStatement>>(`${this.configuration.basePath}/lb3-api/InfStatements/find-or-create-many`,\n            infStatement,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a flat object of entity previews, that are target of a list.\n     * @param pkProject Pk of the project.\n     * @param pkSourceEntity Pk of the source entity to which the entity previews, that are target of a list are related.\n     * @param pkProperty Pk of the property leading from source entity to the entity previews, that are target of a list.\n     * @param pkTargetClass Fk class of the target entity previews, that are target of a list.\n     * @param isOutgoing If true, the source entity is domain, else range.\n     * @param limit number of returned entity previews, that are target of a list.\n     * @param offset offset of the segment of returned entity previews, that are target of a list.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infStatementPaginatedListTargetingEntityPreviews(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<object>;\n    public infStatementPaginatedListTargetingEntityPreviews(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<object>>;\n    public infStatementPaginatedListTargetingEntityPreviews(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<object>>;\n    public infStatementPaginatedListTargetingEntityPreviews(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infStatementPaginatedListTargetingEntityPreviews.');\n        }\n        if (pkSourceEntity === null || pkSourceEntity === undefined) {\n            throw new Error('Required parameter pkSourceEntity was null or undefined when calling infStatementPaginatedListTargetingEntityPreviews.');\n        }\n        if (pkProperty === null || pkProperty === undefined) {\n            throw new Error('Required parameter pkProperty was null or undefined when calling infStatementPaginatedListTargetingEntityPreviews.');\n        }\n        if (pkTargetClass === null || pkTargetClass === undefined) {\n            throw new Error('Required parameter pkTargetClass was null or undefined when calling infStatementPaginatedListTargetingEntityPreviews.');\n        }\n        if (isOutgoing === null || isOutgoing === undefined) {\n            throw new Error('Required parameter isOutgoing was null or undefined when calling infStatementPaginatedListTargetingEntityPreviews.');\n        }\n        if (limit === null || limit === undefined) {\n            throw new Error('Required parameter limit was null or undefined when calling infStatementPaginatedListTargetingEntityPreviews.');\n        }\n        if (offset === null || offset === undefined) {\n            throw new Error('Required parameter offset was null or undefined when calling infStatementPaginatedListTargetingEntityPreviews.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkSourceEntity !== undefined && pkSourceEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkSourceEntity, 'pkSourceEntity');\n        }\n        if (pkProperty !== undefined && pkProperty !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProperty, 'pkProperty');\n        }\n        if (pkTargetClass !== undefined && pkTargetClass !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkTargetClass, 'pkTargetClass');\n        }\n        if (isOutgoing !== undefined && isOutgoing !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>isOutgoing, 'isOutgoing');\n        }\n        if (limit !== undefined && limit !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>limit, 'limit');\n        }\n        if (offset !== undefined && offset !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>offset, 'offset');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<object>(`${this.configuration.basePath}/lb3-api/InfStatements/paginated-list-targeting-entity-previews`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find statements by params.\n     * @param ofProject if true, finds project version. if false, finds repo version.\n     * @param pkProject Primary Key of the Project. If provided and ofProject&#x3D;false, makes a left join with project\n     * @param pkEntity Primary Key of the statement (pk_entity)\n     * @param pkInfoRange Foreign Key of the statement pointing to the range entity (fk_object_info)\n     * @param pkInfoDomain Foreign Key of the statement pointing to the domain entity (fk_subject_info)\n     * @param pkProperty Foreign Key of the statement pointing to the property (fk_property)\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infStatementQueryByParams(ofProject: boolean, pkProject?: number, pkEntity?: number, pkInfoRange?: number, pkInfoDomain?: number, pkProperty?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfStatement>>;\n    public infStatementQueryByParams(ofProject: boolean, pkProject?: number, pkEntity?: number, pkInfoRange?: number, pkInfoDomain?: number, pkProperty?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfStatement>>>;\n    public infStatementQueryByParams(ofProject: boolean, pkProject?: number, pkEntity?: number, pkInfoRange?: number, pkInfoDomain?: number, pkProperty?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfStatement>>>;\n    public infStatementQueryByParams(ofProject: boolean, pkProject?: number, pkEntity?: number, pkInfoRange?: number, pkInfoDomain?: number, pkProperty?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (ofProject === null || ofProject === undefined) {\n            throw new Error('Required parameter ofProject was null or undefined when calling infStatementQueryByParams.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (ofProject !== undefined && ofProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>ofProject, 'ofProject');\n        }\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n        if (pkInfoRange !== undefined && pkInfoRange !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkInfoRange, 'pkInfoRange');\n        }\n        if (pkInfoDomain !== undefined && pkInfoDomain !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkInfoDomain, 'pkInfoDomain');\n        }\n        if (pkProperty !== undefined && pkProperty !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProperty, 'pkProperty');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<InfStatement>>(`${this.configuration.basePath}/lb3-api/InfStatements/find-by-params`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an nested object of statement with everything needed to display the links made from an entity towards sources and digitals.\n     * @param ofProject if true, finds project version. if false, finds repo version.\n     * @param pkProject Primary Key of the Project.\n     * @param pkEntity Primary Key of the entity for which the sources links are needed.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infStatementSourcesAndDigitalsOfEntity(ofProject: boolean, pkProject?: number, pkEntity?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<object>>;\n    public infStatementSourcesAndDigitalsOfEntity(ofProject: boolean, pkProject?: number, pkEntity?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<object>>>;\n    public infStatementSourcesAndDigitalsOfEntity(ofProject: boolean, pkProject?: number, pkEntity?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<object>>>;\n    public infStatementSourcesAndDigitalsOfEntity(ofProject: boolean, pkProject?: number, pkEntity?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (ofProject === null || ofProject === undefined) {\n            throw new Error('Required parameter ofProject was null or undefined when calling infStatementSourcesAndDigitalsOfEntity.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (ofProject !== undefined && ofProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>ofProject, 'ofProject');\n        }\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<object>>(`${this.configuration.basePath}/lb3-api/InfStatements/sources-and-digitals-of-entity`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { InfTemporalEntity } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class InfTemporalEntityService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get a flat object of temporal entities.\n     * @param pkProject Pk of the project.\n     * @param pkSourceEntity Pk of the source entity to which the temporal entities are related.\n     * @param pkProperty Pk of the property leading from source entity to the temporal entities.\n     * @param pkTargetClass Fk class of the target temporal entities.\n     * @param isOutgoing If true, the source entity is domain, else range.\n     * @param limit number of returned temporal entities.\n     * @param offset offset of the segment of returned temporal entities.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infTemporalEntityAlternativeTemporalEntityList(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<object>;\n    public infTemporalEntityAlternativeTemporalEntityList(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<object>>;\n    public infTemporalEntityAlternativeTemporalEntityList(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<object>>;\n    public infTemporalEntityAlternativeTemporalEntityList(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infTemporalEntityAlternativeTemporalEntityList.');\n        }\n        if (pkSourceEntity === null || pkSourceEntity === undefined) {\n            throw new Error('Required parameter pkSourceEntity was null or undefined when calling infTemporalEntityAlternativeTemporalEntityList.');\n        }\n        if (pkProperty === null || pkProperty === undefined) {\n            throw new Error('Required parameter pkProperty was null or undefined when calling infTemporalEntityAlternativeTemporalEntityList.');\n        }\n        if (pkTargetClass === null || pkTargetClass === undefined) {\n            throw new Error('Required parameter pkTargetClass was null or undefined when calling infTemporalEntityAlternativeTemporalEntityList.');\n        }\n        if (isOutgoing === null || isOutgoing === undefined) {\n            throw new Error('Required parameter isOutgoing was null or undefined when calling infTemporalEntityAlternativeTemporalEntityList.');\n        }\n        if (limit === null || limit === undefined) {\n            throw new Error('Required parameter limit was null or undefined when calling infTemporalEntityAlternativeTemporalEntityList.');\n        }\n        if (offset === null || offset === undefined) {\n            throw new Error('Required parameter offset was null or undefined when calling infTemporalEntityAlternativeTemporalEntityList.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkSourceEntity !== undefined && pkSourceEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkSourceEntity, 'pkSourceEntity');\n        }\n        if (pkProperty !== undefined && pkProperty !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProperty, 'pkProperty');\n        }\n        if (pkTargetClass !== undefined && pkTargetClass !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkTargetClass, 'pkTargetClass');\n        }\n        if (isOutgoing !== undefined && isOutgoing !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>isOutgoing, 'isOutgoing');\n        }\n        if (limit !== undefined && limit !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>limit, 'limit');\n        }\n        if (offset !== undefined && offset !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>offset, 'offset');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<object>(`${this.configuration.basePath}/lb3-api/InfTemporalEntities/paginated-list-alternatives`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Relate a nested object of a InfTemporalEntity to the project.\n     * @param pkProject Id of the project\n     * @param isInProject Include or exclude from project.\n     * @param infTemporalEntity data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infTemporalEntityChangeTeEntProjectRelation(pkProject: number, isInProject: boolean, infTemporalEntity: InfTemporalEntity, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<InfTemporalEntity>;\n    public infTemporalEntityChangeTeEntProjectRelation(pkProject: number, isInProject: boolean, infTemporalEntity: InfTemporalEntity, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<InfTemporalEntity>>;\n    public infTemporalEntityChangeTeEntProjectRelation(pkProject: number, isInProject: boolean, infTemporalEntity: InfTemporalEntity, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<InfTemporalEntity>>;\n    public infTemporalEntityChangeTeEntProjectRelation(pkProject: number, isInProject: boolean, infTemporalEntity: InfTemporalEntity, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infTemporalEntityChangeTeEntProjectRelation.');\n        }\n        if (isInProject === null || isInProject === undefined) {\n            throw new Error('Required parameter isInProject was null or undefined when calling infTemporalEntityChangeTeEntProjectRelation.');\n        }\n        if (infTemporalEntity === null || infTemporalEntity === undefined) {\n            throw new Error('Required parameter infTemporalEntity was null or undefined when calling infTemporalEntityChangeTeEntProjectRelation.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (isInProject !== undefined && isInProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>isInProject, 'isInProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<InfTemporalEntity>(`${this.configuration.basePath}/lb3-api/InfTemporalEntities/change-project-relation`,\n            infTemporalEntity,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find all instances of the model matched by filter from the data source.\n     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\\&quot;where\\&quot;:{\\&quot;something\\&quot;:\\&quot;value\\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infTemporalEntityFind(filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfTemporalEntity>>;\n    public infTemporalEntityFind(filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfTemporalEntity>>>;\n    public infTemporalEntityFind(filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfTemporalEntity>>>;\n    public infTemporalEntityFind(filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<InfTemporalEntity>>(`${this.configuration.basePath}/lb3-api/InfTemporalEntities`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find or create many information temporal entities.\n     * @param pkProject Pk of the project\n     * @param infTemporalEntity data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infTemporalEntityFindOrCreateInfTemporalEntities(pkProject: number, infTemporalEntity: Array<InfTemporalEntity>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfTemporalEntity>>;\n    public infTemporalEntityFindOrCreateInfTemporalEntities(pkProject: number, infTemporalEntity: Array<InfTemporalEntity>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfTemporalEntity>>>;\n    public infTemporalEntityFindOrCreateInfTemporalEntities(pkProject: number, infTemporalEntity: Array<InfTemporalEntity>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfTemporalEntity>>>;\n    public infTemporalEntityFindOrCreateInfTemporalEntities(pkProject: number, infTemporalEntity: Array<InfTemporalEntity>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infTemporalEntityFindOrCreateInfTemporalEntities.');\n        }\n        if (infTemporalEntity === null || infTemporalEntity === undefined) {\n            throw new Error('Required parameter infTemporalEntity was null or undefined when calling infTemporalEntityFindOrCreateInfTemporalEntities.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pk_project');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<InfTemporalEntity>>(`${this.configuration.basePath}/lb3-api/InfTemporalEntities/find-or-create-many`,\n            infTemporalEntity,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find or create a temporal entity version.\n     * @param pkProject Id of the project\n     * @param infTemporalEntity data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infTemporalEntityFindOrCreateInfTemporalEntity(pkProject: number, infTemporalEntity: InfTemporalEntity, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<InfTemporalEntity>;\n    public infTemporalEntityFindOrCreateInfTemporalEntity(pkProject: number, infTemporalEntity: InfTemporalEntity, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<InfTemporalEntity>>;\n    public infTemporalEntityFindOrCreateInfTemporalEntity(pkProject: number, infTemporalEntity: InfTemporalEntity, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<InfTemporalEntity>>;\n    public infTemporalEntityFindOrCreateInfTemporalEntity(pkProject: number, infTemporalEntity: InfTemporalEntity, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infTemporalEntityFindOrCreateInfTemporalEntity.');\n        }\n        if (infTemporalEntity === null || infTemporalEntity === undefined) {\n            throw new Error('Required parameter infTemporalEntity was null or undefined when calling infTemporalEntityFindOrCreateInfTemporalEntity.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<InfTemporalEntity>(`${this.configuration.basePath}/lb3-api/InfTemporalEntities/findOrCreate`,\n            infTemporalEntity,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get e schema object of own properties of the temporal entity in project version.\n     * @param pkProject Pk project\n     * @param pkEntity Primary Key of the temporal entity (pk_entity)\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infTemporalEntityOwnProperties(pkProject: number, pkEntity: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<InfTemporalEntity>;\n    public infTemporalEntityOwnProperties(pkProject: number, pkEntity: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<InfTemporalEntity>>;\n    public infTemporalEntityOwnProperties(pkProject: number, pkEntity: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<InfTemporalEntity>>;\n    public infTemporalEntityOwnProperties(pkProject: number, pkEntity: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infTemporalEntityOwnProperties.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling infTemporalEntityOwnProperties.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<InfTemporalEntity>(`${this.configuration.basePath}/lb3-api/InfTemporalEntities/own-properties`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a flat object of temporal entities.\n     * @param pkProject Pk of the project.\n     * @param pkSourceEntity Pk of the source entity to which the temporal entities are related.\n     * @param pkProperty Pk of the property leading from source entity to the temporal entities.\n     * @param pkTargetClass Fk class of the target temporal entities.\n     * @param isOutgoing If true, the source entity is domain, else range.\n     * @param limit number of returned temporal entities.\n     * @param offset offset of the segment of returned temporal entities.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infTemporalEntityTemporalEntityList(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<object>;\n    public infTemporalEntityTemporalEntityList(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<object>>;\n    public infTemporalEntityTemporalEntityList(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<object>>;\n    public infTemporalEntityTemporalEntityList(pkProject: number, pkSourceEntity: number, pkProperty: number, pkTargetClass: number, isOutgoing: boolean, limit: number, offset: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infTemporalEntityTemporalEntityList.');\n        }\n        if (pkSourceEntity === null || pkSourceEntity === undefined) {\n            throw new Error('Required parameter pkSourceEntity was null or undefined when calling infTemporalEntityTemporalEntityList.');\n        }\n        if (pkProperty === null || pkProperty === undefined) {\n            throw new Error('Required parameter pkProperty was null or undefined when calling infTemporalEntityTemporalEntityList.');\n        }\n        if (pkTargetClass === null || pkTargetClass === undefined) {\n            throw new Error('Required parameter pkTargetClass was null or undefined when calling infTemporalEntityTemporalEntityList.');\n        }\n        if (isOutgoing === null || isOutgoing === undefined) {\n            throw new Error('Required parameter isOutgoing was null or undefined when calling infTemporalEntityTemporalEntityList.');\n        }\n        if (limit === null || limit === undefined) {\n            throw new Error('Required parameter limit was null or undefined when calling infTemporalEntityTemporalEntityList.');\n        }\n        if (offset === null || offset === undefined) {\n            throw new Error('Required parameter offset was null or undefined when calling infTemporalEntityTemporalEntityList.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkSourceEntity !== undefined && pkSourceEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkSourceEntity, 'pkSourceEntity');\n        }\n        if (pkProperty !== undefined && pkProperty !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProperty, 'pkProperty');\n        }\n        if (pkTargetClass !== undefined && pkTargetClass !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkTargetClass, 'pkTargetClass');\n        }\n        if (isOutgoing !== undefined && isOutgoing !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>isOutgoing, 'isOutgoing');\n        }\n        if (limit !== undefined && limit !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>limit, 'limit');\n        }\n        if (offset !== undefined && offset !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>offset, 'offset');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<object>(`${this.configuration.basePath}/lb3-api/InfTemporalEntities/paginated-list`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { InfTextProperty } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class InfTextPropertyService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Find all InfTextProperties that are not yet added to the given project.\n     * @param pkProject Pk of the project\n     * @param pkEntity fk of the concerned entity\n     * @param pkClassField fk of the class field\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infTextPropertyFindAlternativeTextProperties(pkProject: number, pkEntity: number, pkClassField: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfTextProperty>>;\n    public infTextPropertyFindAlternativeTextProperties(pkProject: number, pkEntity: number, pkClassField: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfTextProperty>>>;\n    public infTextPropertyFindAlternativeTextProperties(pkProject: number, pkEntity: number, pkClassField: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfTextProperty>>>;\n    public infTextPropertyFindAlternativeTextProperties(pkProject: number, pkEntity: number, pkClassField: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infTextPropertyFindAlternativeTextProperties.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling infTextPropertyFindAlternativeTextProperties.');\n        }\n        if (pkClassField === null || pkClassField === undefined) {\n            throw new Error('Required parameter pkClassField was null or undefined when calling infTextPropertyFindAlternativeTextProperties.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n        if (pkClassField !== undefined && pkClassField !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkClassField, 'pkClassField');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<InfTextProperty>>(`${this.configuration.basePath}/lb3-api/InfTextProperties/findAlternativeTextProperties`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find or create information text properties.\n     * @param pkProject Id of the project\n     * @param infTextProperty data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infTextPropertyFindOrCreateInfTextProperties(pkProject: number, infTextProperty: Array<InfTextProperty>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<InfTextProperty>>;\n    public infTextPropertyFindOrCreateInfTextProperties(pkProject: number, infTextProperty: Array<InfTextProperty>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<InfTextProperty>>>;\n    public infTextPropertyFindOrCreateInfTextProperties(pkProject: number, infTextProperty: Array<InfTextProperty>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<InfTextProperty>>>;\n    public infTextPropertyFindOrCreateInfTextProperties(pkProject: number, infTextProperty: Array<InfTextProperty>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infTextPropertyFindOrCreateInfTextProperties.');\n        }\n        if (infTextProperty === null || infTextProperty === undefined) {\n            throw new Error('Required parameter infTextProperty was null or undefined when calling infTextPropertyFindOrCreateInfTextProperties.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pk_project');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<InfTextProperty>>(`${this.configuration.basePath}/lb3-api/InfTextProperties/find-or-create-many`,\n            infTextProperty,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find or create a InfTextProperty and update the project relation if needed.\n     * @param pkProject Pk of the project\n     * @param infTextProperty data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public infTextPropertyFindOrCreateInfTextProperty(pkProject: number, infTextProperty: InfTextProperty, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<InfTextProperty>;\n    public infTextPropertyFindOrCreateInfTextProperty(pkProject: number, infTextProperty: InfTextProperty, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<InfTextProperty>>;\n    public infTextPropertyFindOrCreateInfTextProperty(pkProject: number, infTextProperty: InfTextProperty, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<InfTextProperty>>;\n    public infTextPropertyFindOrCreateInfTextProperty(pkProject: number, infTextProperty: InfTextProperty, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling infTextPropertyFindOrCreateInfTextProperty.');\n        }\n        if (infTextProperty === null || infTextProperty === undefined) {\n            throw new Error('Required parameter infTextProperty was null or undefined when calling infTextPropertyFindOrCreateInfTextProperty.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<InfTextProperty>(`${this.configuration.basePath}/lb3-api/InfTextProperties/findOrCreate`,\n            infTextProperty,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { PingResponse } from '../model/models';\nimport { ProjectPongRequest } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PingControllerService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public pingControllerPing(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PingResponse>;\n    public pingControllerPing(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PingResponse>>;\n    public pingControllerPing(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PingResponse>>;\n    public pingControllerPing(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<PingResponse>(`${this.configuration.basePath}/ping`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Test get access to project: Only Project members get a response.\n     * @param pkProject \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public pingControllerProjectPing(pkProject?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PingResponse>;\n    public pingControllerProjectPing(pkProject?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PingResponse>>;\n    public pingControllerProjectPing(pkProject?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PingResponse>>;\n    public pingControllerProjectPing(pkProject?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<PingResponse>(`${this.configuration.basePath}/project-ping`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Test post access to project: Only Project members get a response.\n     * @param projectPongRequest \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public pingControllerProjectPong(projectPongRequest?: ProjectPongRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PingResponse>;\n    public pingControllerProjectPong(projectPongRequest?: ProjectPongRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PingResponse>>;\n    public pingControllerProjectPong(projectPongRequest?: ProjectPongRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PingResponse>>;\n    public pingControllerProjectPong(projectPongRequest?: ProjectPongRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PingResponse>(`${this.configuration.basePath}/project-pong`,\n            projectPongRequest,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Test access as system admin: Only system administrators get a response.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public pingControllerSysAdminPing(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PingResponse>;\n    public pingControllerSysAdminPing(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PingResponse>>;\n    public pingControllerSysAdminPing(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PingResponse>>;\n    public pingControllerSysAdminPing(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<PingResponse>(`${this.configuration.basePath}/system-admin-ping`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ProClassFieldConfig } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ProClassFieldConfigService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Deletes instances of ProClassFieldConfig.\n     * @param requestBody Array of Primary Key of ProClassFieldConfigs\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proClassFieldConfigBulkDelete(requestBody: Array<number>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<boolean>;\n    public proClassFieldConfigBulkDelete(requestBody: Array<number>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<boolean>>;\n    public proClassFieldConfigBulkDelete(requestBody: Array<number>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<boolean>>;\n    public proClassFieldConfigBulkDelete(requestBody: Array<number>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (requestBody === null || requestBody === undefined) {\n            throw new Error('Required parameter requestBody was null or undefined when calling proClassFieldConfigBulkDelete.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<boolean>(`${this.configuration.basePath}/lb3-api/ProClassFieldConfigs/bulk-delete`,\n            requestBody,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates or updates instances of ProClassFieldConfig.\n     * @param pkProject Pk of the project\n     * @param proClassFieldConfig Array ProClassFieldConfig\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proClassFieldConfigBulkUpsert(pkProject: number, proClassFieldConfig: Array<ProClassFieldConfig>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<ProClassFieldConfig>;\n    public proClassFieldConfigBulkUpsert(pkProject: number, proClassFieldConfig: Array<ProClassFieldConfig>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<ProClassFieldConfig>>;\n    public proClassFieldConfigBulkUpsert(pkProject: number, proClassFieldConfig: Array<ProClassFieldConfig>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<ProClassFieldConfig>>;\n    public proClassFieldConfigBulkUpsert(pkProject: number, proClassFieldConfig: Array<ProClassFieldConfig>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proClassFieldConfigBulkUpsert.');\n        }\n        if (proClassFieldConfig === null || proClassFieldConfig === undefined) {\n            throw new Error('Required parameter proClassFieldConfig was null or undefined when calling proClassFieldConfigBulkUpsert.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<ProClassFieldConfig>(`${this.configuration.basePath}/lb3-api/ProClassFieldConfigs/bulk-upsert`,\n            proClassFieldConfig,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find ProClassFieldConfig of project\n     * @param pkProject Pk of the project\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proClassFieldConfigOfProject(pkProject: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<ProClassFieldConfig>>;\n    public proClassFieldConfigOfProject(pkProject: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<ProClassFieldConfig>>>;\n    public proClassFieldConfigOfProject(pkProject: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<ProClassFieldConfig>>>;\n    public proClassFieldConfigOfProject(pkProject: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proClassFieldConfigOfProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<ProClassFieldConfig>>(`${this.configuration.basePath}/lb3-api/ProClassFieldConfigs/of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Patch an existing model instance or insert a new one into the data source.\n     * @param proClassFieldConfig Model instance data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proClassFieldConfigPatchOrCreate(proClassFieldConfig?: ProClassFieldConfig, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<ProClassFieldConfig>;\n    public proClassFieldConfigPatchOrCreate(proClassFieldConfig?: ProClassFieldConfig, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<ProClassFieldConfig>>;\n    public proClassFieldConfigPatchOrCreate(proClassFieldConfig?: ProClassFieldConfig, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<ProClassFieldConfig>>;\n    public proClassFieldConfigPatchOrCreate(proClassFieldConfig?: ProClassFieldConfig, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.patch<ProClassFieldConfig>(`${this.configuration.basePath}/lb3-api/ProClassFieldConfigs`,\n            proClassFieldConfig,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { NewProDfhClassProjRel } from '../model/models';\nimport { ProDfhClassProjRel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ProDfhClassProjRelService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates or updates instances of ProDfhClassProjRel.\n     * @param pkProject Project\n     * @param proDfhClassProjRel Array ProDfhClassProjRel\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proDfhClassProjRelBulkUpsert(pkProject: number, proDfhClassProjRel: Array<ProDfhClassProjRel>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<ProDfhClassProjRel>;\n    public proDfhClassProjRelBulkUpsert(pkProject: number, proDfhClassProjRel: Array<ProDfhClassProjRel>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<ProDfhClassProjRel>>;\n    public proDfhClassProjRelBulkUpsert(pkProject: number, proDfhClassProjRel: Array<ProDfhClassProjRel>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<ProDfhClassProjRel>>;\n    public proDfhClassProjRelBulkUpsert(pkProject: number, proDfhClassProjRel: Array<ProDfhClassProjRel>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proDfhClassProjRelBulkUpsert.');\n        }\n        if (proDfhClassProjRel === null || proDfhClassProjRel === undefined) {\n            throw new Error('Required parameter proDfhClassProjRel was null or undefined when calling proDfhClassProjRelBulkUpsert.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<ProDfhClassProjRel>(`${this.configuration.basePath}/lb3-api/ProDfhClassProjRels/bulk-upsert`,\n            proDfhClassProjRel,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Create a new instance of the model and persist it into the data source.\n     * @param newProDfhClassProjRel Model instance data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proDfhClassProjRelCreate(newProDfhClassProjRel?: NewProDfhClassProjRel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<ProDfhClassProjRel>;\n    public proDfhClassProjRelCreate(newProDfhClassProjRel?: NewProDfhClassProjRel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<ProDfhClassProjRel>>;\n    public proDfhClassProjRelCreate(newProDfhClassProjRel?: NewProDfhClassProjRel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<ProDfhClassProjRel>>;\n    public proDfhClassProjRelCreate(newProDfhClassProjRel?: NewProDfhClassProjRel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<ProDfhClassProjRel>(`${this.configuration.basePath}/lb3-api/ProDfhClassProjRels`,\n            newProDfhClassProjRel,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find ProDfhClassProjRel of project\n     * @param pkProject Pk of the project\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proDfhClassProjRelOfProject(pkProject: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<ProDfhClassProjRel>>;\n    public proDfhClassProjRelOfProject(pkProject: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<ProDfhClassProjRel>>>;\n    public proDfhClassProjRelOfProject(pkProject: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<ProDfhClassProjRel>>>;\n    public proDfhClassProjRelOfProject(pkProject: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proDfhClassProjRelOfProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<ProDfhClassProjRel>>(`${this.configuration.basePath}/lb3-api/ProDfhClassProjRels/of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ProDfhProfileProjRel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ProDfhProfileProjRelService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Creates or updates instances of ProDfhProfileProjRel.\n     * @param pkProject Project\n     * @param proDfhProfileProjRel Array ProDfhProfileProjRel\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proDfhProfileProjRelBulkUpsert(pkProject: number, proDfhProfileProjRel: Array<ProDfhProfileProjRel>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<ProDfhProfileProjRel>;\n    public proDfhProfileProjRelBulkUpsert(pkProject: number, proDfhProfileProjRel: Array<ProDfhProfileProjRel>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<ProDfhProfileProjRel>>;\n    public proDfhProfileProjRelBulkUpsert(pkProject: number, proDfhProfileProjRel: Array<ProDfhProfileProjRel>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<ProDfhProfileProjRel>>;\n    public proDfhProfileProjRelBulkUpsert(pkProject: number, proDfhProfileProjRel: Array<ProDfhProfileProjRel>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proDfhProfileProjRelBulkUpsert.');\n        }\n        if (proDfhProfileProjRel === null || proDfhProfileProjRel === undefined) {\n            throw new Error('Required parameter proDfhProfileProjRel was null or undefined when calling proDfhProfileProjRelBulkUpsert.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<ProDfhProfileProjRel>(`${this.configuration.basePath}/lb3-api/ProDfhProfileProjRels/bulk-upsert`,\n            proDfhProfileProjRel,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find ProDfhProfileProjRel of project where enabled is true\n     * @param pkProject Pk of the project\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proDfhProfileProjRelOfProject(pkProject: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<ProDfhProfileProjRel>>;\n    public proDfhProfileProjRelOfProject(pkProject: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<ProDfhProfileProjRel>>>;\n    public proDfhProfileProjRelOfProject(pkProject: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<ProDfhProfileProjRel>>>;\n    public proDfhProfileProjRelOfProject(pkProject: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proDfhProfileProjRelOfProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<ProDfhProfileProjRel>>(`${this.configuration.basePath}/lb3-api/ProDfhProfileProjRels/of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ProInfoProjRel } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ProInfoProjRelService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Updates the ProInfoProjRel of all found by fk_project and fk_entity.\n     * @param pkProject fk_project\n     * @param proInfoProjRel Array of ProInfoProjRel (fk_project must be equal to pkProject)\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proInfoProjRelBulkUpdateEprAttributes(pkProject: number, proInfoProjRel: Array<ProInfoProjRel>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<ProInfoProjRel>;\n    public proInfoProjRelBulkUpdateEprAttributes(pkProject: number, proInfoProjRel: Array<ProInfoProjRel>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<ProInfoProjRel>>;\n    public proInfoProjRelBulkUpdateEprAttributes(pkProject: number, proInfoProjRel: Array<ProInfoProjRel>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<ProInfoProjRel>>;\n    public proInfoProjRelBulkUpdateEprAttributes(pkProject: number, proInfoProjRel: Array<ProInfoProjRel>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proInfoProjRelBulkUpdateEprAttributes.');\n        }\n        if (proInfoProjRel === null || proInfoProjRel === undefined) {\n            throw new Error('Required parameter proInfoProjRel was null or undefined when calling proInfoProjRelBulkUpdateEprAttributes.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<ProInfoProjRel>(`${this.configuration.basePath}/lb3-api/ProInfoProjRels/bulk-update-attributes`,\n            proInfoProjRel,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find all instances of the model matched by filter from the data source.\n     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\\&quot;where\\&quot;:{\\&quot;something\\&quot;:\\&quot;value\\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proInfoProjRelFind(filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<ProInfoProjRel>>;\n    public proInfoProjRelFind(filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<ProInfoProjRel>>>;\n    public proInfoProjRelFind(filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<ProInfoProjRel>>>;\n    public proInfoProjRelFind(filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<ProInfoProjRel>>(`${this.configuration.basePath}/lb3-api/ProInfoProjRels`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Marks the statement as favorite for the given fk_project.\n     * @param pkProject fk_project\n     * @param pkStatement fk_entity\n     * @param body True, if the statement is outgoing, else false\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proInfoProjRelMarkStatementAsFavorite(pkProject: number, pkStatement: number, body: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<ProInfoProjRel>;\n    public proInfoProjRelMarkStatementAsFavorite(pkProject: number, pkStatement: number, body: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<ProInfoProjRel>>;\n    public proInfoProjRelMarkStatementAsFavorite(pkProject: number, pkStatement: number, body: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<ProInfoProjRel>>;\n    public proInfoProjRelMarkStatementAsFavorite(pkProject: number, pkStatement: number, body: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proInfoProjRelMarkStatementAsFavorite.');\n        }\n        if (pkStatement === null || pkStatement === undefined) {\n            throw new Error('Required parameter pkStatement was null or undefined when calling proInfoProjRelMarkStatementAsFavorite.');\n        }\n        if (body === null || body === undefined) {\n            throw new Error('Required parameter body was null or undefined when calling proInfoProjRelMarkStatementAsFavorite.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkStatement !== undefined && pkStatement !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkStatement, 'pkStatement');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<ProInfoProjRel>(`${this.configuration.basePath}/lb3-api/ProInfoProjRels/mark-statement-as-favorite`,\n            body,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Patch an existing model instance or insert a new one into the data source.\n     * @param proInfoProjRel Model instance data\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proInfoProjRelPatchOrCreate(proInfoProjRel?: ProInfoProjRel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<ProInfoProjRel>;\n    public proInfoProjRelPatchOrCreate(proInfoProjRel?: ProInfoProjRel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<ProInfoProjRel>>;\n    public proInfoProjRelPatchOrCreate(proInfoProjRel?: ProInfoProjRel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<ProInfoProjRel>>;\n    public proInfoProjRelPatchOrCreate(proInfoProjRel?: ProInfoProjRel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.patch<ProInfoProjRel>(`${this.configuration.basePath}/lb3-api/ProInfoProjRels`,\n            proInfoProjRel,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates the ProInfoProjRel found by fk_project and fk_entity.\n     * @param pkProject fk_project\n     * @param pkEntity fk_entity\n     * @param proInfoProjRel Instance of ProInfoProjRel (fk_project and fk_entity will be ignored)\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proInfoProjRelUpdateEprAttributes(pkProject: number, pkEntity: number, proInfoProjRel: ProInfoProjRel, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<ProInfoProjRel>;\n    public proInfoProjRelUpdateEprAttributes(pkProject: number, pkEntity: number, proInfoProjRel: ProInfoProjRel, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<ProInfoProjRel>>;\n    public proInfoProjRelUpdateEprAttributes(pkProject: number, pkEntity: number, proInfoProjRel: ProInfoProjRel, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<ProInfoProjRel>>;\n    public proInfoProjRelUpdateEprAttributes(pkProject: number, pkEntity: number, proInfoProjRel: ProInfoProjRel, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proInfoProjRelUpdateEprAttributes.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling proInfoProjRelUpdateEprAttributes.');\n        }\n        if (proInfoProjRel === null || proInfoProjRel === undefined) {\n            throw new Error('Required parameter proInfoProjRel was null or undefined when calling proInfoProjRelUpdateEprAttributes.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<ProInfoProjRel>(`${this.configuration.basePath}/lb3-api/ProInfoProjRels/updateEprAttributes`,\n            proInfoProjRel,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ProProject } from '../model/models';\nimport { ProTextProperty } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ProProjectService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Create a new project with a label and a description.\n     * @param accountId Id of account to associate the persistent item with.\n     * @param pkLanguage Default language of the project, language of the label and the text property.\n     * @param label Label of the project.\n     * @param textProperty Description of the project.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proProjectCreateWithLabelAndDescription(accountId: number, pkLanguage: string, label: string, textProperty?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<boolean>>;\n    public proProjectCreateWithLabelAndDescription(accountId: number, pkLanguage: string, label: string, textProperty?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<boolean>>>;\n    public proProjectCreateWithLabelAndDescription(accountId: number, pkLanguage: string, label: string, textProperty?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<boolean>>>;\n    public proProjectCreateWithLabelAndDescription(accountId: number, pkLanguage: string, label: string, textProperty?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (accountId === null || accountId === undefined) {\n            throw new Error('Required parameter accountId was null or undefined when calling proProjectCreateWithLabelAndDescription.');\n        }\n        if (pkLanguage === null || pkLanguage === undefined) {\n            throw new Error('Required parameter pkLanguage was null or undefined when calling proProjectCreateWithLabelAndDescription.');\n        }\n        if (label === null || label === undefined) {\n            throw new Error('Required parameter label was null or undefined when calling proProjectCreateWithLabelAndDescription.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (accountId !== undefined && accountId !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>accountId, 'accountId');\n        }\n        if (pkLanguage !== undefined && pkLanguage !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkLanguage, 'pkLanguage');\n        }\n        if (label !== undefined && label !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>label, 'label');\n        }\n        if (textProperty !== undefined && textProperty !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>textProperty, 'textProperty');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<boolean>>(`${this.configuration.basePath}/lb3-api/ProProjects/create-with-label-and-description`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get basic information about the project (language, name)\n     * @param pkProject Pk of project\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proProjectGetBasics(pkProject: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<ProProject>>;\n    public proProjectGetBasics(pkProject: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<ProProject>>>;\n    public proProjectGetBasics(pkProject: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<ProProject>>>;\n    public proProjectGetBasics(pkProject: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proProjectGetBasics.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<ProProject>>(`${this.configuration.basePath}/lb3-api/ProProjects/get-basics`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the projects of account.\n     * @param accountId Id of the account\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proProjectOfAccount(accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<ProTextProperty>>;\n    public proProjectOfAccount(accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<ProTextProperty>>>;\n    public proProjectOfAccount(accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<ProTextProperty>>>;\n    public proProjectOfAccount(accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (accountId === null || accountId === undefined) {\n            throw new Error('Required parameter accountId was null or undefined when calling proProjectOfAccount.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (accountId !== undefined && accountId !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>accountId, 'accountId');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<ProTextProperty>>(`${this.configuration.basePath}/lb3-api/ProProjects/of-account`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ProTextProperty } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ProTextPropertyService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Dletes items in the array of ProTextProperty. Checks for each item if fk_project matches given pkProject \n     * @param pkProject Pk of the project\n     * @param proTextProperty Array of ProTextPropertys\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proTextPropertyBulkDelete(pkProject: number, proTextProperty: Array<ProTextProperty>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<ProTextProperty>>;\n    public proTextPropertyBulkDelete(pkProject: number, proTextProperty: Array<ProTextProperty>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<ProTextProperty>>>;\n    public proTextPropertyBulkDelete(pkProject: number, proTextProperty: Array<ProTextProperty>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<ProTextProperty>>>;\n    public proTextPropertyBulkDelete(pkProject: number, proTextProperty: Array<ProTextProperty>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proTextPropertyBulkDelete.');\n        }\n        if (proTextProperty === null || proTextProperty === undefined) {\n            throw new Error('Required parameter proTextProperty was null or undefined when calling proTextPropertyBulkDelete.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<Array<ProTextProperty>>(`${this.configuration.basePath}/lb3-api/ProTextProperties/bulk-delete`,\n            proTextProperty,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Inserts or updates items in the array of ProTextProperty. If pk_entity is givenand existing, an update is done, else an insert\n     * @param pkProject Pk of the project\n     * @param proTextProperty Array of ProTextPropertys\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proTextPropertyBulkUpsert(pkProject: number, proTextProperty: Array<ProTextProperty>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<ProTextProperty>>;\n    public proTextPropertyBulkUpsert(pkProject: number, proTextProperty: Array<ProTextProperty>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<ProTextProperty>>>;\n    public proTextPropertyBulkUpsert(pkProject: number, proTextProperty: Array<ProTextProperty>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<ProTextProperty>>>;\n    public proTextPropertyBulkUpsert(pkProject: number, proTextProperty: Array<ProTextProperty>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proTextPropertyBulkUpsert.');\n        }\n        if (proTextProperty === null || proTextProperty === undefined) {\n            throw new Error('Required parameter proTextProperty was null or undefined when calling proTextPropertyBulkUpsert.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<ProTextProperty>>(`${this.configuration.basePath}/lb3-api/ProTextProperties/bulk-upsert`,\n            proTextProperty,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the text-properties of the project.\n     * @param pkProject Pk of the project\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public proTextPropertyOfProject(pkProject: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<ProTextProperty>>;\n    public proTextPropertyOfProject(pkProject: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<ProTextProperty>>>;\n    public proTextPropertyOfProject(pkProject: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<ProTextProperty>>>;\n    public proTextPropertyOfProject(pkProject: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling proTextPropertyOfProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<ProTextProperty>>(`${this.configuration.basePath}/lb3-api/ProTextProperties/of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { GetEntityLabelConfigResponse } from '../model/models';\nimport { ProEntityLabelConfig } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ProjectConfigurationService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Delete entity label config by class and project.\n     * @param pkProject \n     * @param fkClass \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public projectConfigControllerDeleteEntityLabelConfig(pkProject?: number, fkClass?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public projectConfigControllerDeleteEntityLabelConfig(pkProject?: number, fkClass?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public projectConfigControllerDeleteEntityLabelConfig(pkProject?: number, fkClass?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public projectConfigControllerDeleteEntityLabelConfig(pkProject?: number, fkClass?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (fkClass !== undefined && fkClass !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>fkClass, 'fkClass');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/entity-label-config`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the entity label config by class and project. This always includes the default configuration as well.\n     * @param pkProject \n     * @param fkClass \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public projectConfigControllerGetEntityLabelConfig(pkProject?: number, fkClass?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GetEntityLabelConfigResponse>;\n    public projectConfigControllerGetEntityLabelConfig(pkProject?: number, fkClass?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GetEntityLabelConfigResponse>>;\n    public projectConfigControllerGetEntityLabelConfig(pkProject?: number, fkClass?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GetEntityLabelConfigResponse>>;\n    public projectConfigControllerGetEntityLabelConfig(pkProject?: number, fkClass?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (fkClass !== undefined && fkClass !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>fkClass, 'fkClass');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<GetEntityLabelConfigResponse>(`${this.configuration.basePath}/entity-label-config`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Insert or update the entity label config by class and project.\n     * @param proEntityLabelConfig \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public projectConfigControllerPostEntityLabelConfig(proEntityLabelConfig?: ProEntityLabelConfig, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<ProEntityLabelConfig>;\n    public projectConfigControllerPostEntityLabelConfig(proEntityLabelConfig?: ProEntityLabelConfig, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<ProEntityLabelConfig>>;\n    public projectConfigControllerPostEntityLabelConfig(proEntityLabelConfig?: ProEntityLabelConfig, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<ProEntityLabelConfig>>;\n    public projectConfigControllerPostEntityLabelConfig(proEntityLabelConfig?: ProEntityLabelConfig, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<ProEntityLabelConfig>(`${this.configuration.basePath}/entity-label-config`,\n            proEntityLabelConfig,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { PubAccount } from '../model/models';\nimport { Role } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PubAccountService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get Roles of the Account\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public pubAccountGetRoles(id: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<Role>>;\n    public pubAccountGetRoles(id: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<Role>>>;\n    public pubAccountGetRoles(id: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<Role>>>;\n    public pubAccountGetRoles(id: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling pubAccountGetRoles.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<Role>>(`${this.configuration.basePath}/lb3-api/PubAccounts/${encodeURIComponent(String(id))}/get-roles`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a list of all projects associated with this account.\n     * @param id \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public pubAccountListProjects(id: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<PubAccount>>;\n    public pubAccountListProjects(id: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<PubAccount>>>;\n    public pubAccountListProjects(id: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<PubAccount>>>;\n    public pubAccountListProjects(id: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (id === null || id === undefined) {\n            throw new Error('Required parameter id was null or undefined when calling pubAccountListProjects.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<PubAccount>>(`${this.configuration.basePath}/lb3-api/PubAccounts/${encodeURIComponent(String(id))}/list-projects`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Login a user with username/email and password.\n     * @param body \n     * @param include Related objects to include in the response. See the description of return value for more details.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public pubAccountLogin(body: object, include?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<object>;\n    public pubAccountLogin(body: object, include?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<object>>;\n    public pubAccountLogin(body: object, include?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<object>>;\n    public pubAccountLogin(body: object, include?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (body === null || body === undefined) {\n            throw new Error('Required parameter body was null or undefined when calling pubAccountLogin.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (include !== undefined && include !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>include, 'include');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<object>(`${this.configuration.basePath}/lb3-api/PubAccounts/login`,\n            body,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Logout a user with access token.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public pubAccountLogout(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public pubAccountLogout(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public pubAccountLogout(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public pubAccountLogout(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/lb3-api/PubAccounts/logout`,\n            null,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get all accounts with their project pks and their roles\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public pubAccountWithRolesAndProjects(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<PubAccount>>;\n    public pubAccountWithRolesAndProjects(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<PubAccount>>>;\n    public pubAccountWithRolesAndProjects(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<PubAccount>>>;\n    public pubAccountWithRolesAndProjects(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<PubAccount>>(`${this.configuration.basePath}/lb3-api/PubAccounts/with-roles-and-projects`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { GvSchemaObject } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class RamListService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get the schema object for the ram list.\n     * @param pkProject Primary key of the project\n     * @param pkEntity Primary key of the entity (the expression)\n     * @param fkProperty fkProperty of the statement connecting the entity via -&gt; 1218 &#x3D; mentions / 117 &#x3D; is about / 1334 &#x3D; refers to -&gt; with Expression / Expr. Portion / Chunk / Cell\n     * @param refersTo \\&quot;Chunk\\&quot; or \\&quot;Cell\\&quot; to restrict query to Chunk or Cell as subject of referst to statements\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public ramListControllerGetRamList(pkProject: number, pkEntity: number, fkProperty: number, refersTo?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GvSchemaObject>;\n    public ramListControllerGetRamList(pkProject: number, pkEntity: number, fkProperty: number, refersTo?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GvSchemaObject>>;\n    public ramListControllerGetRamList(pkProject: number, pkEntity: number, fkProperty: number, refersTo?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GvSchemaObject>>;\n    public ramListControllerGetRamList(pkProject: number, pkEntity: number, fkProperty: number, refersTo?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling ramListControllerGetRamList.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling ramListControllerGetRamList.');\n        }\n        if (fkProperty === null || fkProperty === undefined) {\n            throw new Error('Required parameter fkProperty was null or undefined when calling ramListControllerGetRamList.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n        if (fkProperty !== undefined && fkProperty !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>fkProperty, 'fkProperty');\n        }\n        if (refersTo !== undefined && refersTo !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>refersTo, 'refersTo');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<GvSchemaObject>(`${this.configuration.basePath}/get-ram-list`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { InfPersistentItem } from '../model/models';\nimport { SchemaObject } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SchemaObjectService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Add entity with outgoing statements and namings to project.\n     * @param pkProject Primary key of the project\n     * @param pkEntity Primary key of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public schemaObjectAddEntityToProject(pkProject: number, pkEntity: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<SchemaObject>>;\n    public schemaObjectAddEntityToProject(pkProject: number, pkEntity: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<SchemaObject>>>;\n    public schemaObjectAddEntityToProject(pkProject: number, pkEntity: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<SchemaObject>>>;\n    public schemaObjectAddEntityToProject(pkProject: number, pkEntity: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling schemaObjectAddEntityToProject.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling schemaObjectAddEntityToProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<SchemaObject>>(`${this.configuration.basePath}/lb3-api/SchemaObjects/add-entity-to-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Remove entity with outgoing statements and namings from project.\n     * @param pkProject Primary key of the project\n     * @param pkEntity Primary key of the entity\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public schemaObjectRemoveEntityFromProject(pkProject: number, pkEntity: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<SchemaObject>>;\n    public schemaObjectRemoveEntityFromProject(pkProject: number, pkEntity: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<SchemaObject>>>;\n    public schemaObjectRemoveEntityFromProject(pkProject: number, pkEntity: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<SchemaObject>>>;\n    public schemaObjectRemoveEntityFromProject(pkProject: number, pkEntity: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling schemaObjectRemoveEntityFromProject.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling schemaObjectRemoveEntityFromProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<SchemaObject>>(`${this.configuration.basePath}/lb3-api/SchemaObjects/remove-entity-from-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get a object containing apllations and definition of a type (project variant).\n     * @param pkProject Pk of the project.\n     * @param pkType Pk of the type.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public schemaObjectTypeOfProject(pkProject: number, pkType: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<InfPersistentItem>;\n    public schemaObjectTypeOfProject(pkProject: number, pkType: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<InfPersistentItem>>;\n    public schemaObjectTypeOfProject(pkProject: number, pkType: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<InfPersistentItem>>;\n    public schemaObjectTypeOfProject(pkProject: number, pkType: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling schemaObjectTypeOfProject.');\n        }\n        if (pkType === null || pkType === undefined) {\n            throw new Error('Required parameter pkType was null or undefined when calling schemaObjectTypeOfProject.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkType !== undefined && pkType !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkType, 'pkType');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<InfPersistentItem>(`${this.configuration.basePath}/lb3-api/SchemaObjects/type-of-project`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { GvFieldPageReq } from '../model/models';\nimport { GvPaginationAlternativeLeafItemsReq } from '../model/models';\nimport { GvPaginationObject } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SubfieldPageControllerService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param gvPaginationAlternativeLeafItemsReq \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public subfieldPageControllerAlternativeLeafItems(gvPaginationAlternativeLeafItemsReq?: GvPaginationAlternativeLeafItemsReq, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GvPaginationObject>;\n    public subfieldPageControllerAlternativeLeafItems(gvPaginationAlternativeLeafItemsReq?: GvPaginationAlternativeLeafItemsReq, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GvPaginationObject>>;\n    public subfieldPageControllerAlternativeLeafItems(gvPaginationAlternativeLeafItemsReq?: GvPaginationAlternativeLeafItemsReq, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GvPaginationObject>>;\n    public subfieldPageControllerAlternativeLeafItems(gvPaginationAlternativeLeafItemsReq?: GvPaginationAlternativeLeafItemsReq, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<GvPaginationObject>(`${this.configuration.basePath}/subfield-page/alternative-leaf-items`,\n            gvPaginationAlternativeLeafItemsReq,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param gvFieldPageReq \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public subfieldPageControllerLoadSubfieldPage(gvFieldPageReq?: GvFieldPageReq, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GvPaginationObject>;\n    public subfieldPageControllerLoadSubfieldPage(gvFieldPageReq?: GvFieldPageReq, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GvPaginationObject>>;\n    public subfieldPageControllerLoadSubfieldPage(gvFieldPageReq?: GvFieldPageReq, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GvPaginationObject>>;\n    public subfieldPageControllerLoadSubfieldPage(gvFieldPageReq?: GvFieldPageReq, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<GvPaginationObject>(`${this.configuration.basePath}/subfield-page/load-subfield-page`,\n            gvFieldPageReq,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { SysClassField } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SysClassFieldService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Find all instances of the model matched by filter from the data source.\n     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\\&quot;where\\&quot;:{\\&quot;something\\&quot;:\\&quot;value\\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public sysClassFieldFind(filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<SysClassField>>;\n    public sysClassFieldFind(filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<SysClassField>>>;\n    public sysClassFieldFind(filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<SysClassField>>>;\n    public sysClassFieldFind(filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<SysClassField>>(`${this.configuration.basePath}/lb3-api/SysClassFields`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param body \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public sysClassFieldFindComplex(body?: object, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<SysClassField>>;\n    public sysClassFieldFindComplex(body?: object, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<SysClassField>>>;\n    public sysClassFieldFindComplex(body?: object, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<SysClassField>>>;\n    public sysClassFieldFindComplex(body?: object, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<SysClassField>>(`${this.configuration.basePath}/lb3-api/SysClassFields/findComplex`,\n            body,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { SysClassHasTypeProperty } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SysClassHasTypePropertyService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Find all instances of the model matched by filter from the data source.\n     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\\&quot;where\\&quot;:{\\&quot;something\\&quot;:\\&quot;value\\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public sysClassHasTypePropertyFind(filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<SysClassHasTypeProperty>>;\n    public sysClassHasTypePropertyFind(filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<SysClassHasTypeProperty>>>;\n    public sysClassHasTypePropertyFind(filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<SysClassHasTypeProperty>>>;\n    public sysClassHasTypePropertyFind(filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<SysClassHasTypeProperty>>(`${this.configuration.basePath}/lb3-api/SysClassHasTypeProperties`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { SysSystemRelevantClass } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SysSystemRelevantClassService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Replace or create all items in the array.\n     * @param sysSystemRelevantClass Array of SysSystemRelevantClass\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public sysSystemRelevantClassBulkReplaceOrCreate(sysSystemRelevantClass: Array<SysSystemRelevantClass>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<SysSystemRelevantClass>>;\n    public sysSystemRelevantClassBulkReplaceOrCreate(sysSystemRelevantClass: Array<SysSystemRelevantClass>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<SysSystemRelevantClass>>>;\n    public sysSystemRelevantClassBulkReplaceOrCreate(sysSystemRelevantClass: Array<SysSystemRelevantClass>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<SysSystemRelevantClass>>>;\n    public sysSystemRelevantClassBulkReplaceOrCreate(sysSystemRelevantClass: Array<SysSystemRelevantClass>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n        if (sysSystemRelevantClass === null || sysSystemRelevantClass === undefined) {\n            throw new Error('Required parameter sysSystemRelevantClass was null or undefined when calling sysSystemRelevantClassBulkReplaceOrCreate.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/x-www-form-urlencoded',\n            'application/xml',\n            'text/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<SysSystemRelevantClass>>(`${this.configuration.basePath}/lb3-api/SysSystemRelevantClasses/bulk-replace-or-create`,\n            sysSystemRelevantClass,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find all instances of the model matched by filter from the data source.\n     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\\&quot;where\\&quot;:{\\&quot;something\\&quot;:\\&quot;value\\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public sysSystemRelevantClassFind(filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<SysSystemRelevantClass>>;\n    public sysSystemRelevantClassFind(filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<SysSystemRelevantClass>>>;\n    public sysSystemRelevantClassFind(filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<SysSystemRelevantClass>>>;\n    public sysSystemRelevantClassFind(filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<SysSystemRelevantClass>>(`${this.configuration.basePath}/lb3-api/SysSystemRelevantClasses`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { SysSystemType } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SysSystemTypeService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Find all instances of the model matched by filter from the data source.\n     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\\&quot;where\\&quot;:{\\&quot;something\\&quot;:\\&quot;value\\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public sysSystemTypeFind(filter?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<Array<SysSystemType>>;\n    public sysSystemTypeFind(filter?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpResponse<Array<SysSystemType>>>;\n    public sysSystemTypeFind(filter?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<HttpEvent<Array<SysSystemType>>>;\n    public sysSystemTypeFind(filter?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml' | 'text/xml' | 'application/javascript' | 'text/javascript'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (filter !== undefined && filter !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>filter, 'filter');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml',\n                'text/xml',\n                'application/javascript',\n                'text/javascript'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<Array<SysSystemType>>(`${this.configuration.basePath}/lb3-api/SysSystemTypes`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { SysConfigValue } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SystemConfigurationService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public sysConfigControllerGetSystemConfig(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<SysConfigValue>;\n    public sysConfigControllerGetSystemConfig(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<SysConfigValue>>;\n    public sysConfigControllerGetSystemConfig(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<SysConfigValue>>;\n    public sysConfigControllerGetSystemConfig(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<SysConfigValue>(`${this.configuration.basePath}/get-system-config`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param sysConfigValue Sets or updates the system configuration. This affects the basic behavior of geovistory (i.e. for all projects).       The provided (json) value is validated against the json schema. If invalid, the request is rejected and the current configuration stays unchanged.       Hint: You can download the current cofiguration using \\&quot;/get-system-config\\&quot;, modify it and upload the modified version here.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public sysConfigControllerSetSystemConfig(sysConfigValue: SysConfigValue, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public sysConfigControllerSetSystemConfig(sysConfigValue: SysConfigValue, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public sysConfigControllerSetSystemConfig(sysConfigValue: SysConfigValue, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public sysConfigControllerSetSystemConfig(sysConfigValue: SysConfigValue, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n        if (sysConfigValue === null || sysConfigValue === undefined) {\n            throw new Error('Required parameter sysConfigValue was null or undefined when calling sysConfigControllerSetSystemConfig.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/set-system-config`,\n            sysConfigValue,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param sysConfigValue Validates the configuration without persisting it.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public sysConfigControllerValidateSystemConfig(sysConfigValue: SysConfigValue, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public sysConfigControllerValidateSystemConfig(sysConfigValue: SysConfigValue, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public sysConfigControllerValidateSystemConfig(sysConfigValue: SysConfigValue, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public sysConfigControllerValidateSystemConfig(sysConfigValue: SysConfigValue, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n        if (sysConfigValue === null || sysConfigValue === undefined) {\n            throw new Error('Required parameter sysConfigValue was null or undefined when calling sysConfigControllerValidateSystemConfig.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/validate-system-config`,\n            sysConfigValue,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { GetTablePageOptions } from '../model/models';\nimport { GvSchemaObject } from '../model/models';\nimport { TablePageResponse } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class TableService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Get the columns of a table (digital) with column names and column mappings.\n     * @param pkProject \n     * @param pkDigital \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public tableControllerGetTableColumns(pkProject: number, pkDigital: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GvSchemaObject>;\n    public tableControllerGetTableColumns(pkProject: number, pkDigital: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GvSchemaObject>>;\n    public tableControllerGetTableColumns(pkProject: number, pkDigital: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GvSchemaObject>>;\n    public tableControllerGetTableColumns(pkProject: number, pkDigital: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling tableControllerGetTableColumns.');\n        }\n        if (pkDigital === null || pkDigital === undefined) {\n            throw new Error('Required parameter pkDigital was null or undefined when calling tableControllerGetTableColumns.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkDigital !== undefined && pkDigital !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkDigital, 'pkDigital');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<GvSchemaObject>(`${this.configuration.basePath}/get-columns-of-table`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get rows (with cells) of a table according to the specified columns, limit, offset and sorting.\n     * @param pkProject \n     * @param pkEntity \n     * @param getTablePageOptions \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public tableControllerGetTablePage(pkProject: number, pkEntity: number, getTablePageOptions?: GetTablePageOptions, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<TablePageResponse>;\n    public tableControllerGetTablePage(pkProject: number, pkEntity: number, getTablePageOptions?: GetTablePageOptions, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<TablePageResponse>>;\n    public tableControllerGetTablePage(pkProject: number, pkEntity: number, getTablePageOptions?: GetTablePageOptions, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<TablePageResponse>>;\n    public tableControllerGetTablePage(pkProject: number, pkEntity: number, getTablePageOptions?: GetTablePageOptions, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n        if (pkProject === null || pkProject === undefined) {\n            throw new Error('Required parameter pkProject was null or undefined when calling tableControllerGetTablePage.');\n        }\n        if (pkEntity === null || pkEntity === undefined) {\n            throw new Error('Required parameter pkEntity was null or undefined when calling tableControllerGetTablePage.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pkProject !== undefined && pkProject !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkProject, 'pkProject');\n        }\n        if (pkEntity !== undefined && pkEntity !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pkEntity, 'pkEntity');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<TablePageResponse>(`${this.configuration.basePath}/get-table-page`,\n            getTablePageOptions,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { WarEntityPreview } from '../model/models';\nimport { WarEntityPreviewPaginatedByPkReq } from '../model/models';\nimport { WarEntityPreviewSearchExistingReq } from '../model/models';\nimport { WareEntityPreviewPage } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class WarEntityPreviewControllerService {\n\n    protected basePath = 'http://0.0.0.0:3000';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param warEntityPreviewPaginatedByPkReq \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public warEntityPreviewControllerPaginatedListByPks(warEntityPreviewPaginatedByPkReq?: WarEntityPreviewPaginatedByPkReq, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<Array<WarEntityPreview>>;\n    public warEntityPreviewControllerPaginatedListByPks(warEntityPreviewPaginatedByPkReq?: WarEntityPreviewPaginatedByPkReq, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<Array<WarEntityPreview>>>;\n    public warEntityPreviewControllerPaginatedListByPks(warEntityPreviewPaginatedByPkReq?: WarEntityPreviewPaginatedByPkReq, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<Array<WarEntityPreview>>>;\n    public warEntityPreviewControllerPaginatedListByPks(warEntityPreviewPaginatedByPkReq?: WarEntityPreviewPaginatedByPkReq, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<Array<WarEntityPreview>>(`${this.configuration.basePath}/war-entity-previews/paginated-list-by-pks`,\n            warEntityPreviewPaginatedByPkReq,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param warEntityPreviewSearchExistingReq \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public warEntityPreviewControllerSearch(warEntityPreviewSearchExistingReq?: WarEntityPreviewSearchExistingReq, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<WareEntityPreviewPage>;\n    public warEntityPreviewControllerSearch(warEntityPreviewSearchExistingReq?: WarEntityPreviewSearchExistingReq, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<WareEntityPreviewPage>>;\n    public warEntityPreviewControllerSearch(warEntityPreviewSearchExistingReq?: WarEntityPreviewSearchExistingReq, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<WareEntityPreviewPage>>;\n    public warEntityPreviewControllerSearch(warEntityPreviewSearchExistingReq?: WarEntityPreviewSearchExistingReq, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<WareEntityPreviewPage>(`${this.configuration.basePath}/war-entity-previews/search`,\n            warEntityPreviewSearchExistingReq,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param warEntityPreviewSearchExistingReq \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public warEntityPreviewControllerSearchExisting(warEntityPreviewSearchExistingReq?: WarEntityPreviewSearchExistingReq, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<WareEntityPreviewPage>;\n    public warEntityPreviewControllerSearchExisting(warEntityPreviewSearchExistingReq?: WarEntityPreviewSearchExistingReq, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<WareEntityPreviewPage>>;\n    public warEntityPreviewControllerSearchExisting(warEntityPreviewSearchExistingReq?: WarEntityPreviewSearchExistingReq, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<WareEntityPreviewPage>>;\n    public warEntityPreviewControllerSearchExisting(warEntityPreviewSearchExistingReq?: WarEntityPreviewSearchExistingReq, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (accesstoken) required\n        credential = this.configuration.lookupCredential('accesstoken');\n        if (credential) {\n            headers = headers.set('authorization', credential);\n        }\n\n        // authentication (jwt) required\n        credential = this.configuration.lookupCredential('jwt');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<WareEntityPreviewPage>(`${this.configuration.basePath}/war-entity-previews/search-existing`,\n            warEntityPreviewSearchExistingReq,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","export * from './account.service';\nimport { AccountService } from './account.service';\nexport * from './analysis.service';\nimport { AnalysisService } from './analysis.service';\nexport * from './contentTree.service';\nimport { ContentTreeService } from './contentTree.service';\nexport * from './datChunk.service';\nimport { DatChunkService } from './datChunk.service';\nexport * from './datChunkController.service';\nimport { DatChunkControllerService } from './datChunkController.service';\nexport * from './datColumn.service';\nimport { DatColumnService } from './datColumn.service';\nexport * from './datDigital.service';\nimport { DatDigitalService } from './datDigital.service';\nexport * from './datNamespace.service';\nimport { DatNamespaceService } from './datNamespace.service';\nexport * from './dfhClassController.service';\nimport { DfhClassControllerService } from './dfhClassController.service';\nexport * from './dfhLabel.service';\nimport { DfhLabelService } from './dfhLabel.service';\nexport * from './dfhProfile.service';\nimport { DfhProfileService } from './dfhProfile.service';\nexport * from './dfhPropertyController.service';\nimport { DfhPropertyControllerService } from './dfhPropertyController.service';\nexport * from './factoidController.service';\nimport { FactoidControllerService } from './factoidController.service';\nexport * from './importTableController.service';\nimport { ImportTableControllerService } from './importTableController.service';\nexport * from './infLanguage.service';\nimport { InfLanguageService } from './infLanguage.service';\nexport * from './infPersistentItem.service';\nimport { InfPersistentItemService } from './infPersistentItem.service';\nexport * from './infPlace.service';\nimport { InfPlaceService } from './infPlace.service';\nexport * from './infStatement.service';\nimport { InfStatementService } from './infStatement.service';\nexport * from './infTemporalEntity.service';\nimport { InfTemporalEntityService } from './infTemporalEntity.service';\nexport * from './infTextProperty.service';\nimport { InfTextPropertyService } from './infTextProperty.service';\nexport * from './pingController.service';\nimport { PingControllerService } from './pingController.service';\nexport * from './proClassFieldConfig.service';\nimport { ProClassFieldConfigService } from './proClassFieldConfig.service';\nexport * from './proDfhClassProjRel.service';\nimport { ProDfhClassProjRelService } from './proDfhClassProjRel.service';\nexport * from './proDfhProfileProjRel.service';\nimport { ProDfhProfileProjRelService } from './proDfhProfileProjRel.service';\nexport * from './proInfoProjRel.service';\nimport { ProInfoProjRelService } from './proInfoProjRel.service';\nexport * from './proProject.service';\nimport { ProProjectService } from './proProject.service';\nexport * from './proTextProperty.service';\nimport { ProTextPropertyService } from './proTextProperty.service';\nexport * from './projectConfiguration.service';\nimport { ProjectConfigurationService } from './projectConfiguration.service';\nexport * from './pubAccount.service';\nimport { PubAccountService } from './pubAccount.service';\nexport * from './ramList.service';\nimport { RamListService } from './ramList.service';\nexport * from './schemaObject.service';\nimport { SchemaObjectService } from './schemaObject.service';\nexport * from './subfieldPageController.service';\nimport { SubfieldPageControllerService } from './subfieldPageController.service';\nexport * from './sysClassField.service';\nimport { SysClassFieldService } from './sysClassField.service';\nexport * from './sysClassHasTypeProperty.service';\nimport { SysClassHasTypePropertyService } from './sysClassHasTypeProperty.service';\nexport * from './sysSystemRelevantClass.service';\nimport { SysSystemRelevantClassService } from './sysSystemRelevantClass.service';\nexport * from './sysSystemType.service';\nimport { SysSystemTypeService } from './sysSystemType.service';\nexport * from './systemConfiguration.service';\nimport { SystemConfigurationService } from './systemConfiguration.service';\nexport * from './table.service';\nimport { TableService } from './table.service';\nexport * from './warEntityPreviewController.service';\nimport { WarEntityPreviewControllerService } from './warEntityPreviewController.service';\nexport const APIS = [AccountService, AnalysisService, ContentTreeService, DatChunkService, DatChunkControllerService, DatColumnService, DatDigitalService, DatNamespaceService, DfhClassControllerService, DfhLabelService, DfhProfileService, DfhPropertyControllerService, FactoidControllerService, ImportTableControllerService, InfLanguageService, InfPersistentItemService, InfPlaceService, InfStatementService, InfTemporalEntityService, InfTextPropertyService, PingControllerService, ProClassFieldConfigService, ProDfhClassProjRelService, ProDfhProfileProjRelService, ProInfoProjRelService, ProProjectService, ProTextPropertyService, ProjectConfigurationService, PubAccountService, RamListService, SchemaObjectService, SubfieldPageControllerService, SysClassFieldService, SysClassHasTypePropertyService, SysSystemRelevantClassService, SysSystemTypeService, SystemConfigurationService, TableService, WarEntityPreviewControllerService];\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { DimensionValueObjectType } from './dimensionValueObjectType';\n\n\n/**\n * If present, defines a specific list type for the class.\n */\nexport interface GvSubentityTargetType { \n    appellation?: GvSubentityTargetType.AppellationEnum;\n    language?: GvSubentityTargetType.LanguageEnum;\n    place?: GvSubentityTargetType.PlaceEnum;\n    timePrimitive?: GvSubentityTargetType.TimePrimitiveEnum;\n    langString?: GvSubentityTargetType.LangStringEnum;\n    dimension?: DimensionValueObjectType;\n    entityPreview?: GvSubentityTargetType.EntityPreviewEnum;\n    typeItem?: GvSubentityTargetType.TypeItemEnum;\n    timeSpan?: GvSubentityTargetType.TimeSpanEnum;\n    textProperty?: GvSubentityTargetType.TextPropertyEnum;\n}\nexport namespace GvSubentityTargetType {\n    export type AppellationEnum = 'true';\n    export const AppellationEnum = {\n        True: 'true' as AppellationEnum\n    };\n    export type LanguageEnum = 'true';\n    export const LanguageEnum = {\n        True: 'true' as LanguageEnum\n    };\n    export type PlaceEnum = 'true';\n    export const PlaceEnum = {\n        True: 'true' as PlaceEnum\n    };\n    export type TimePrimitiveEnum = 'true';\n    export const TimePrimitiveEnum = {\n        True: 'true' as TimePrimitiveEnum\n    };\n    export type LangStringEnum = 'true';\n    export const LangStringEnum = {\n        True: 'true' as LangStringEnum\n    };\n    export type EntityPreviewEnum = 'true';\n    export const EntityPreviewEnum = {\n        True: 'true' as EntityPreviewEnum\n    };\n    export type TypeItemEnum = 'true';\n    export const TypeItemEnum = {\n        True: 'true' as TypeItemEnum\n    };\n    export type TimeSpanEnum = 'true';\n    export const TimeSpanEnum = {\n        True: 'true' as TimeSpanEnum\n    };\n    export type TextPropertyEnum = 'true';\n    export const TextPropertyEnum = {\n        True: 'true' as TextPropertyEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { GvSubentitFieldPageReq } from './gvSubentitFieldPageReq';\nimport { DimensionValueObjectType } from './dimensionValueObjectType';\n\n\n/**\n * If present, defines a specific list type for the class.\n */\nexport interface GvTargetType { \n    appellation?: GvTargetType.AppellationEnum;\n    language?: GvTargetType.LanguageEnum;\n    place?: GvTargetType.PlaceEnum;\n    timePrimitive?: GvTargetType.TimePrimitiveEnum;\n    langString?: GvTargetType.LangStringEnum;\n    dimension?: DimensionValueObjectType;\n    entityPreview?: GvTargetType.EntityPreviewEnum;\n    typeItem?: GvTargetType.TypeItemEnum;\n    timeSpan?: GvTargetType.TimeSpanEnum;\n    textProperty?: GvTargetType.TextPropertyEnum;\n    temporalEntity?: Array<GvSubentitFieldPageReq>;\n}\nexport namespace GvTargetType {\n    export type AppellationEnum = 'true';\n    export const AppellationEnum = {\n        True: 'true' as AppellationEnum\n    };\n    export type LanguageEnum = 'true';\n    export const LanguageEnum = {\n        True: 'true' as LanguageEnum\n    };\n    export type PlaceEnum = 'true';\n    export const PlaceEnum = {\n        True: 'true' as PlaceEnum\n    };\n    export type TimePrimitiveEnum = 'true';\n    export const TimePrimitiveEnum = {\n        True: 'true' as TimePrimitiveEnum\n    };\n    export type LangStringEnum = 'true';\n    export const LangStringEnum = {\n        True: 'true' as LangStringEnum\n    };\n    export type EntityPreviewEnum = 'true';\n    export const EntityPreviewEnum = {\n        True: 'true' as EntityPreviewEnum\n    };\n    export type TypeItemEnum = 'true';\n    export const TypeItemEnum = {\n        True: 'true' as TypeItemEnum\n    };\n    export type TimeSpanEnum = 'true';\n    export const TimeSpanEnum = {\n        True: 'true' as TimeSpanEnum\n    };\n    export type TextPropertyEnum = 'true';\n    export const TextPropertyEnum = {\n        True: 'true' as TextPropertyEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface QueryFilterData { \n    subgroup?: QueryFilterData.SubgroupEnum;\n    operator?: QueryFilterData.OperatorEnum;\n    classes?: Array<number>;\n    types?: Array<number>;\n    outgoingProperties?: Array<number>;\n    ingoingProperties?: Array<number>;\n    searchTerm?: string;\n}\nexport namespace QueryFilterData {\n    export type SubgroupEnum = 'property' | 'classAndType';\n    export const SubgroupEnum = {\n        Property: 'property' as SubgroupEnum,\n        ClassAndType: 'classAndType' as SubgroupEnum\n    };\n    export type OperatorEnum = 'IS' | 'IS NOT' | 'ENTITY_LABEL_CONTAINS' | 'AND' | 'OR';\n    export const OperatorEnum = {\n        Is: 'IS' as OperatorEnum,\n        IsNot: 'IS NOT' as OperatorEnum,\n        EntityLabelContains: 'ENTITY_LABEL_CONTAINS' as OperatorEnum,\n        And: 'AND' as OperatorEnum,\n        Or: 'OR' as OperatorEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { DimensionValueObjectType } from './dimensionValueObjectType';\n\n\n/**\n * If present, defines a specific list type for the class.\n */\nexport interface SysConfigValueObjectType { \n    appellation?: SysConfigValueObjectType.AppellationEnum;\n    language?: SysConfigValueObjectType.LanguageEnum;\n    place?: SysConfigValueObjectType.PlaceEnum;\n    timePrimitive?: SysConfigValueObjectType.TimePrimitiveEnum;\n    langString?: SysConfigValueObjectType.LangStringEnum;\n    dimension?: DimensionValueObjectType;\n}\nexport namespace SysConfigValueObjectType {\n    export type AppellationEnum = 'true';\n    export const AppellationEnum = {\n        True: 'true' as AppellationEnum\n    };\n    export type LanguageEnum = 'true';\n    export const LanguageEnum = {\n        True: 'true' as LanguageEnum\n    };\n    export type PlaceEnum = 'true';\n    export const PlaceEnum = {\n        True: 'true' as PlaceEnum\n    };\n    export type TimePrimitiveEnum = 'true';\n    export const TimePrimitiveEnum = {\n        True: 'true' as TimePrimitiveEnum\n    };\n    export type LangStringEnum = 'true';\n    export const LangStringEnum = {\n        True: 'true' as LangStringEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface TimePrimitiveWithCal { \n    julianDay: number;\n    duration: TimePrimitiveWithCal.DurationEnum;\n    calendar: TimePrimitiveWithCal.CalendarEnum;\n}\nexport namespace TimePrimitiveWithCal {\n    export type DurationEnum = '1 century' | '1 decade' | '1 year' | '1 month' | '1 day' | '1 hour' | '1 minute' | '1 second';\n    export const DurationEnum = {\n        Century: '1 century' as DurationEnum,\n        Decade: '1 decade' as DurationEnum,\n        Year: '1 year' as DurationEnum,\n        Month: '1 month' as DurationEnum,\n        Day: '1 day' as DurationEnum,\n        Hour: '1 hour' as DurationEnum,\n        Minute: '1 minute' as DurationEnum,\n        Second: '1 second' as DurationEnum\n    };\n    export type CalendarEnum = 'gregorian' | 'julian';\n    export const CalendarEnum = {\n        Gregorian: 'gregorian' as CalendarEnum,\n        Julian: 'julian' as CalendarEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { WarStatementTimePrimitiveVTPart } from './warStatementTimePrimitiveVTPart';\n\n\nexport interface WarStatementTimePrimitiveVT { \n    pkEntity: number;\n    fkClass: number;\n    julianDay: number;\n    label: string;\n    duration: WarStatementTimePrimitiveVT.DurationEnum;\n    calendar: WarStatementTimePrimitiveVT.CalendarEnum;\n    from: WarStatementTimePrimitiveVTPart;\n    to: WarStatementTimePrimitiveVTPart;\n}\nexport namespace WarStatementTimePrimitiveVT {\n    export type DurationEnum = '1 century' | '1 decade' | '1 year' | '1 month' | '1 day' | '1 hour' | '1 minute' | '1 second';\n    export const DurationEnum = {\n        Century: '1 century' as DurationEnum,\n        Decade: '1 decade' as DurationEnum,\n        Year: '1 year' as DurationEnum,\n        Month: '1 month' as DurationEnum,\n        Day: '1 day' as DurationEnum,\n        Hour: '1 hour' as DurationEnum,\n        Minute: '1 minute' as DurationEnum,\n        Second: '1 second' as DurationEnum\n    };\n    export type CalendarEnum = 'gregorian' | 'julian';\n    export const CalendarEnum = {\n        Gregorian: 'gregorian' as CalendarEnum,\n        Julian: 'julian' as CalendarEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { AnalysisDefinition } from './analysisDefinition';\n\n\nexport interface AnalysisTableExportRequest { \n    fileType: AnalysisTableExportRequest.FileTypeEnum;\n    analysisDefinition: AnalysisDefinition;\n    fkProject: number;\n}\nexport namespace AnalysisTableExportRequest {\n    export type FileTypeEnum = 'json' | 'csv';\n    export const FileTypeEnum = {\n        Json: 'json' as FileTypeEnum,\n        Csv: 'csv' as FileTypeEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { QueryPathSegment } from './queryPathSegment';\n\n\nexport interface ColDef { \n    ofRootTable?: boolean;\n    preventGroupBy?: boolean;\n    defaultType?: ColDef.DefaultTypeEnum;\n    label?: string;\n    id: string;\n    queryPath?: Array<QueryPathSegment>;\n}\nexport namespace ColDef {\n    export type DefaultTypeEnum = 'entity_preview' | 'entity_label' | 'class_label' | 'type_label' | 'temporal_distribution' | 'space_and_time_cont';\n    export const DefaultTypeEnum = {\n        EntityPreview: 'entity_preview' as DefaultTypeEnum,\n        EntityLabel: 'entity_label' as DefaultTypeEnum,\n        ClassLabel: 'class_label' as DefaultTypeEnum,\n        TypeLabel: 'type_label' as DefaultTypeEnum,\n        TemporalDistribution: 'temporal_distribution' as DefaultTypeEnum,\n        SpaceAndTimeCont: 'space_and_time_cont' as DefaultTypeEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { TColFilters } from './tColFilters';\n\n\nexport interface GetTablePageOptions { \n    limit: number;\n    offset: number;\n    columns?: Array<string>;\n    sortBy: string;\n    sortDirection: GetTablePageOptions.SortDirectionEnum;\n    filters?: TColFilters;\n}\nexport namespace GetTablePageOptions {\n    export type SortDirectionEnum = 'ASC' | 'DESC';\n    export const SortDirectionEnum = {\n        Asc: 'ASC' as SortDirectionEnum,\n        Desc: 'DESC' as SortDirectionEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { QueryPathSegmentData } from './queryPathSegmentData';\n\n\nexport interface QueryPathSegment { \n    type?: QueryPathSegment.TypeEnum;\n    data?: QueryPathSegmentData;\n}\nexport namespace QueryPathSegment {\n    export type TypeEnum = 'properties' | 'classes';\n    export const TypeEnum = {\n        Properties: 'properties' as TypeEnum,\n        Classes: 'classes' as TypeEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface TColFilterNum { \n    operator: TColFilterNum.OperatorEnum;\n    value: number;\n}\nexport namespace TColFilterNum {\n    export type OperatorEnum = '=' | '<' | '>';\n    export const OperatorEnum = {\n        Equal: '=' as OperatorEnum,\n        LessThan: '<' as OperatorEnum,\n        GreaterThan: '>' as OperatorEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface TColFilterTxt { \n    operator: TColFilterTxt.OperatorEnum;\n    value: string;\n}\nexport namespace TColFilterTxt {\n    export type OperatorEnum = '%iLike%';\n    export const OperatorEnum = {\n        ILike: '%iLike%' as OperatorEnum\n    };\n}\n\n\n","/**\n * geovistory\n * Geovistory  Platform for Digital History\n *\n * The version of the OpenAPI document: 1.0.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface WarStatementGeoJson { \n    type: WarStatementGeoJson.TypeEnum;\n    coordinates: Array<number>;\n}\nexport namespace WarStatementGeoJson {\n    export type TypeEnum = 'Point';\n    export const TypeEnum = {\n        Point: 'Point' as TypeEnum\n    };\n}\n\n\n"]}